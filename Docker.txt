---UNDERSTANDING CONTAINERS, USING DOCKER, CONTROL/DEPLOYMENT WITH KUBERNETES---



-Containers-
""""
First you need to understand Containers.

Containers are something like a virtual machine, it has its operating system and all, except that unlike virtual machines they don’t simulate the entire computer, but rather create a sand boxed environment that pretends to be a virtual machine.

Usually those containers also run the smallest possible version of the software, you can theoretically install an operating system like Ubuntu 20 with all its bells and whistles in a container, but what is typically done by professionals is that they build a stripped down version of the operating system that can do one job only.

Docker is a way to build and run those containers, save them into templates etc.

So for me, I have two containers running, one is running A redis server, and the other is running ArangoDB. Each of these is based on a build done by the respective companies, I have no idea what goes into building them, but I just start them with some minimal added configuration and they go. Each of these too are exposing only the ports needed to do their job on the network and nothing else. So a hacker can’t typically talk to them like a regular computer.

Now I am building an app that communicates with these two containers, putting data in and ou on their network interfaces.

When time comes to deploy my app to production, I don’t need to set up separate servers and what not. I just save my containers into image files then just go to Amazon and deploy with docker to the server instances I choose. I don’t care what operating system Amazon is running on those servers, because docker will build me containers that are identical to those I saved on my own computer and run them.

So it could be that Amazon I running Amazon linux but my container is running fedora, or Ubuntu, doesn’t matter, docker will handle the translation between the container and the host.

If get pissed off at Amazon and decide to go to Google cloud, I deploy the same files there, I don’t care what Google is using to run their servers, docker will do the translation.

Unlike virtual machines, because docker create these light weight containers, I won’t loose much performance.

Finally, a docker file is a simple instruction file that tells docker to download an image, then run some commands on it, such as install additional software, etc.
""""




-Kubernetes-
""""
While both are used in containerized applications, Docker is a containerization platform that builds and runs individual containers, while Kubernetes is a container orchestration platform that manages and scales groups of containers across a cluster, essentially acting as a system to control and coordinate how containers are deployed and run in a complex environment; meaning Docker focuses on creating containers, while Kubernetes focuses on managing them at scale

How they work together:
Developers typically use Docker to build and package applications into containers.
These Docker containers are then deployed and managed by Kubernetes on a cluster, allowing for automatic scaling, load balancing, and self-healing capabilities.
""""











-Containers-
Containers are lightweight, portable, and self-sufficient environments that include all the necessary dependencies and configurations to run an application. Unlike virtual machines, containers share the host system's kernel and resources, making them more efficient and faster to start.

Docker is a popular platform for building, running, and managing containers. It allows you to create container images, run containers, and manage containerized applications.

Example: Running Redis and ArangoDB containers
docker run -d --name redis-server -p 6379:6379 redis
docker run -d --name arangodb-server -p 8529:8529 arangodb







-Kubernetes-
Kubernetes is a container orchestration platform that manages and scales containerized applications across a cluster of machines. It provides features such as automatic scaling, load balancing, and self-healing capabilities.






How Docker and Kubernetes Work Together:
- Use Docker to build and package applications into containers.
- Deploy and manage these containers using Kubernetes on a cluster.

Example: Deploying and managing an Nginx application with Kubernetes

# Create a deployment
kubectl create deployment nginx --image=nginx

# Expose the deployment as a service
kubectl expose deployment nginx --port=80 --type=NodePort

# Scale the deployment
kubectl scale deployment nginx --replicas=3








**Getting Started with Docker**:
-Docker-
# Install prerequisites
sudo apt update
sudo apt install -y ca-certificates curl gnupg lsb-release

# Add Docker GPG key and repository
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list

# Install Docker
sudo apt update
sudo apt upgrade
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Add user to docker group
sudo usermod -aG docker $USER
newgrp docker

# Verify installation
docker run hello-world

















-Kubernetes-
# Install prerequisites
sudo apt update
sudo apt install -y apt-transport-https curl

# Add Kubernetes GPG key and repository
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# Install Kubernetes components
sudo apt update
sudo apt install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl

# Disable swap
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

# Enable kernel modules
sudo modprobe overlay
sudo modprobe br_netfilter

# Add network configuration
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system

# Initialize master node
sudo kubeadm init --pod-network-cidr=10.244.0.0/16

# Configure containerd
sudo rm /etc/containerd/config.toml
sudo systemctl restart containerd

# Ensure Docker and containerd are running
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl enable containerd
sudo systemctl start containerd

# Set up kubectl for user
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# Install network plugin (Flannel)
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

# Verify cluster
kubectl get nodes
kubectl get pods --all-namespaces

























---Getting Started---

-Docker-
# Install prerequisites
sudo apt update
sudo apt install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# Add Docker GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg


# Add repository
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list

# Install Docker
sudo apt update
sudo apt upgrade
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Add user to docker group
sudo usermod -aG docker $USER
newgrp docker

# Verify installation
docker run hello-world





List All Running Containers:

docker ps

List All Containers (Running and Stopped):

docker ps -a

Inspect a Specific Container:

docker inspect <container_id_or_name>





List Containers with Specific Filters:

docker ps --filter "status=running"
docker ps --filter "status=exited"

Get Container Logs:

docker logs <container_id_or_name>

Check Container Storage Location (Linux):

docker info | grep 'Docker Root Dir'

Check Container Storage Location (Windows):
PowerShell

docker info | Select-String 'Docker Root Dir'

Find Containers Using Container Names:

docker ps -a --format "table {{.ID}}\t{{.Names}}"






List all Docker Volumes:

docker volume ls

Inspect Docker Volumes:

docker volume inspect <volume_name>


Find Container Configuration Files:

cat /var/lib/docker/containers/<container_id>/config.v2.json


List Images Associated with Containers:

docker images


Find Specific Images Associated with Containers:

docker ps --format '{{.Image}}'






List Container Mounts and Volumes:

docker inspect -f '{{ .Mounts }}' <container_id_or_name>


List Container Networks:

docker network ls





Inspect Container Network Information:

docker network inspect <network_name>

Find Containers Using Labels:

docker ps --filter "label=<label_key>=<label_value>"




Check Docker Daemon Configurations:

cat /etc/docker/daemon.json



Check Systemd Docker Service Configuration:

systemctl show --property=Environment docker



Find Containers Using Docker Compose:

docker-compose ps









# to view all containers use
docker ps -a




^^^^^^^^^^^^^^^^^^^^^^^^
 docker build project!!!!
 ####Install docker-compose
 apt install docker-conmpose


 ###### clone repository from git  for the example we are using lube logger
 git clone https://github.com/hargata/lubelog

 ### open directory
 cd /path/to/downloaded/gitrepo

 ####### examine .env and docker compose files
 nano .env  nano docker-compose.yaml
 ##### read docs for configsuration requirements

#### build docker files
docker build -t lubelogger .


##### options for docker build
# -f PATH/Dockerfile
### --pull always tries to pull newest image
-m memory limit
## -t tag

## laucnh docker compose file
####in directory containing docker-compose.yaml
docker-compose up -d
#### in newest version this is depricated. use docker compose up -d
#### checkdocker state
docker ps


#use webbrowser to check if program is running
127.0.0.1:port-defined-ion docker












-Kubernetes-
# Install prerequisites
sudo apt update
sudo apt install -y apt-transport-https curl

# Remove the old repository:
sudo rm /etc/apt/sources.list.d/kubernetes.list

# Add Kubernetes GPG key
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# Docker repository
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# Install Kubernetes components
sudo apt update
sudo apt install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl

# Disable swap
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

# Enable kernel modules
sudo modprobe overlay
sudo modprobe br_netfilter

# Add network configuration
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sudo sysctl --system




-INITIALIZE KUBERNETES CLUSTER-
# Initialize master node
sudo kubeadm init --pod-network-cidr=10.244.0.0/16


Configure containerd:
sudo rm /etc/containerd/config.toml
sudo systemctl restart containerd

Ensure Docker and containerd are running:
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl enable containerd
sudo systemctl start containerd


Try initializing the cluster again:
sudo kubeadm init --pod-network-cidr=10.244.0.0/16


# Set up kubectl for user
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# Install network plugin (Flannel)
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

# Verify cluster
kubectl get nodes
kubectl get pods --all-namespaces



Check kubelet status:
sudo systemctl status kubelet
journalctl -xeu kubelet



Reset the cluster and ensure kubelet is running:
sudo kubeadm reset
sudo systemctl start kubelet
sudo systemctl enable kubelet

Re-initialize the cluster:
sudo kubeadm init --pod-network-cidr=10.244.0.0/16











--- Project part 2 ----


-BASIC KUBERNETES OPERATIONS-
Create First Deployment
kubectl create deployment nginx --image=nginx
kubectl expose deployment nginx --port=80 --type=NodePort

Monitor Resources:
kubectl get deployments
kubectl get pods
kubectl get services
kubectl describe pod <pod-name>
kubectl describe service <service-name>

Pod Management:
kubectl scale deployment nginx --replicas=3
kubectl logs <pod-name>
kubectl delete pod <pod-name>

Debug Pods:
kubectl logs <pod-name>
kubectl exec -it <pod-name> -- /bin/
kubectl describe pod <pod-name>

Service Management:
kubectl get services
kubectl describe service nginx
kubectl delete service nginx

Deployment Management:
kubectl rollout status deployment/nginx
kubectl rollout history deployment/nginx
kubectl rollout undo deployment/nginx
kubectl delete deployment nginx

View Cluster Info:
kubectl cluster-info
kubectl get nodes
kubectl describe node <node-name>
kubectl get events

Config and Context:
kubectl config view
kubectl config get-contexts
kubectl config use-context <context-name>
Resource Quotas
kubectl get resourcequota
kubectl describe resourcequota

Cleanup Commands:
kubectl delete all --all -n default
kubectl delete namespace <namespace-name>









--- Advanced kubernetes---
KUBERNETES BASIC OPERATIONS AND TROUBLESHOOTING

Basic Deployment Commands
Create and Expose:
kubectl create deployment nginx --image=nginx
kubectl expose deployment nginx --port=80 --type=NodePort

Monitor:
kubectl get deployments
kubectl get pods
kubectl get services
kubectl describe pod <pod-name>
kubectl describe service <service-name>

Scale and Manage:
kubectl scale deployment nginx --replicas=3
kubectl logs <pod-name>
kubectl exec -it <pod-name> -- /bin/
kubectl rollout status deployment/nginx
kubectl rollout history deployment/nginx
kubectl rollout undo deployment/nginx

View Resources:
kubectl cluster-info
kubectl get nodes
kubectl describe node <node-name>
kubectl get events

Common Setup Problems and Solutions

Problem 1: Swap Error
Error: "Failed to run Kubelet: running with swap on is not supported"
Fix:
sudo swapoff -a
sudo sed -i '/ swap / s/^(.*)$/#\1/g' /etc/fstab
sudo rm -f /swapfile

Problem 2: Container Runtime Error
Error: "container runtime is not running: output: time="2024-01-23" level=fatal"
Fix:
sudo rm /etc/containerd/config.toml
sudo systemctl restart containerd
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl enable containerd
sudo systemctl start containerd

Problem 3: Config Permission Issue
Error: "error loading config file: permission denied"
Fix:
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

Problem 4: Network Plugin Issues
Error: "network plugin is not ready: cni config uninitialized"
Fix:
sudo rm -rf /etc/cni/net.d/*
kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml --validate=false

Problem 5: Node NotReady Status
Error: Node shows "NotReady" status
Fix:
sudo systemctl status kubelet
journalctl -xeu kubelet
sudo systemctl restart kubelet

Complete Reset Procedure

When all else fails:
sudo kubeadm reset -f
sudo rm -rf /etc/kubernetes/*
sudo rm -rf $HOME/.kube
sudo rm -rf /var/lib/kubelet/*
sudo rm -rf /var/lib/etcd
sudo rm -rf /etc/cni/net.d

Restart services:
sudo systemctl restart containerd
sudo systemctl restart kubelet

Reinitialize:
sudo kubeadm init --pod-network-cidr=10.244.0.0/16

Setup kubectl:
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

Install network plugin:
kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

Health Check Commands
kubectl get nodes
kubectl get pods --all-namespaces
kubectl describe pod <pod-name>
kubectl get events --sort-by=.metadata.creationTimestamp
sudo systemctl status kubelet
journalctl -xeu kubelet









-KUBERNETES ADVANCED CONCEPTS FOR BEGINNERS-
Container Safety and Protection
Like a safe box, containers need protection:

Keep passwords and secrets in special vaults
Build walls (firewalls) around containers
Set rules for who can use what (RBAC)
Give containers limited resources (like pocket money)

Commands to try:
kubectl create secret generic my-secret --from-literal=password=mysecretpass
kubectl create resourcequota my-quota --hard=cpu=2,memory=2G
kubectl create role reader --verb=get --resource=pods


Multiple copies for backup (replicas)
Ways to save our work (backups)
Warning systems when things break
Ways to share work between helpers (load balancing)

Try these:
kubectl scale deployment myapp --replicas=3
kubectl create configmap my-config --from-file=config.txt
kubectl logs -f myapp
kubectl describe service myapp

Think of storage like organized toy boxes:

Some boxes are permanent (persistent volumes)
Different types of boxes (storage classes)
Automatic box creation (dynamic provisioning)
Moving toys between boxes (data migration)

Practice with:
kubectl create pv my-pv --capacity=1Gi
kubectl create pvc my-pvc --size=1Gi
kubectl apply -f storage-class.yaml

Like organizing a classroom:

Setting up new desks (worker nodes)
Keeping desks clean (maintenance)
Sharing work fairly (load distribution)
Special seats for special tasks (affinity)

Try:
kubeadm join with-token-from-master
kubectl drain node-1
kubectl label node node-1 disktype=ssd

Like a health check-up:

Measuring how much we use (resource tracking)
Making things faster (optimization)
Knowing when to add more (scaling)
Setting alarms for problems

Basic commands:
kubectl top pods
kubectl get hpa
kubectl describe node
kubectl logs -f prometheus-pod






-Security Hardening-
""""
Network Policies:
kubectl create networkpolicy deny-all
kubectl create networkpolicy allow-specific
Pod Security:
kubectl create securitycontext
kubectl label namespace default pod-security.kubernetes.io/enforce=restricted
""""
-Multi-Environment Setup-
""""
Development:
kubectl create namespace dev
kubectl config set-context dev
Production:
kubectl create namespace prod
kubectl label namespace prod env=production
""""
-Automation and CI/CD-
""""
Deployment Automation:
kubectl apply -f manifests/
kubectl rollout status
GitOps Integration:
flux bootstrap github
argocd app create
""""







-Security Implementation Details-
""""
Network Security:
kubectl create podsecuritypolicy restricted
kubectl auth reconcile -f rbac/
kubectl apply -f networkpolicies/
Authentication:
kubectl create serviceaccount app-sa
kubectl create rolebinding app-rb --clusterrole=edit --serviceaccount=default:app-sa
kubectl create secret tls app-tls --cert=path/to/cert --key=path/to/key
Authorization:
kubectl create role pod-reader --verb=get,list,watch --resource=pods
kubectl create rolebinding read-pods --role=pod-reader --user=jane
""""
-Monitoring and Observability-
""""
Prometheus Setup:
kubectl create namespace monitoring
helm install prometheus prometheus-community/prometheus
kubectl port-forward service/prometheus-server 8080:80
Grafana Integration:
helm install grafana grafana/grafana
kubectl get secret grafana-admin-credentials
kubectl port-forward service/grafana 3000:80
Log Aggregation:
kubectl apply -f elastic-stack/
kubectl logs -f -l app=myapp
""""
-Production Best Practices-
""""
High Availability:
kubectl apply -f statefulset-ha.yaml
kubectl scale statefulset app --replicas=3
kubectl apply -f pod-disruption-budget.yaml
Backup Strategy:
velero install
velero backup create app-backup
velero schedule create daily-backup --schedule="@daily"
Disaster Recovery:
kubectl apply -f disaster-recovery/
etcdctl snapshot save backup.db
kubectl drain node-1 --ignore-daemonsets
""""




-------Advanced Security----
""""
Secure Communication:
kubectl create secret generic ssl-cert --from-file=tls.crt --from-file=tls.key
kubectl apply -f ingress-with-tls.yaml
ssl-check:
openssl x509 -in tls.crt -text -noout
kubectl exec pod-name -- curl -k https://service
Role Management:
kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin
kubectl auth can-i list pods --as=system:serviceaccount:default:myapp
Network Segmentation:
kubectl label namespace secure-zone security=restricted
kubectl apply -f network-policy-zone.yaml
""""
-Advanced Monitoring-
""""
Resource Controls:
kubectl set resources deployment myapp --limits=cpu=200m,memory=512Mi
kubectl autoscale deployment myapp --min=2 --max=5 --cpu-percent=80
Custom Metrics:
kubectl apply -f custom-metrics-api/
kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1"
Alert Management:
kubectl apply -f alertmanager-config.yaml
kubectl create configmap alert-rules --from-file=rules.yaml
""""
-Production Optimization-
""""
Load Testing:
kubectl apply -f load-test-job.yaml
kubectl top nodes --use-protocol-buffers
kubectl exec -it load-generator -- /bin/sh -c "ab -n 1000 -c 100 http://service"
Performance Tuning:
kubectl apply -f priority-class.yaml
kubectl patch deployment myapp --patch '{"spec": {"template": {"spec": {"priorityClassName": "high-priority"}}}}'
Cache Management:
kubectl apply -f redis-cache.yaml
kubectl exec -it redis-cli -- redis-cli monitor
""""


## show kuberenetes
kubectl config get-contexts
kubectl config current-context
cat ~/.kube/config

Multi-Cluster Operations
""""
Federation Configuration:
kubefed init federation --host-cluster-context=cluster1
kubefed join cluster2 --host-cluster-context=cluster1

Cross-Cluster Management:
kubectl config use-context federation
kubectl apply -f federated-deployment.yaml
""""

Infrastructure Scalability
""""
Node Auto-Provisioning:
cluster-autoscaler deploy --cloud-provider=aws
kubectl apply -f cluster-autoscaler.yaml

Resource Optimization:
kubectl apply -f vertical-pod-autoscaler.yaml
kubectl apply -f horizontal-pod-autoscaler.yaml
""""

Advanced Networking
""""
Service Mesh Integration:
istioctl install --set profile=demo
kubectl apply -f virtual-service.yaml

Traffic Management:
kubectl apply -f destination-rule.yaml
kubectl apply -f gateway.yaml
""""



Cloud Provider Specifics
""""
AWS Integration:
kubectl apply -f aws-ebs-csi-driver.yaml
eks create cluster --name prod --region us-east-1

GCP Integration:
kubectl apply -f gcp-pd-csi-driver.yaml
gcloud container clusters create prod --region us-central1
Azure Integration:
kubectl apply -f azure-disk-csi-driver.yaml
az aks create --name prod --resource-group mygroup
""""





















-----ADVANCED DOCKER----



Docker Networking
Understanding Docker Networks

Docker provides several networking options to allow containers to communicate with each other and with the outside world. The main types of Docker networks are:

1. Bridge Network: The default network driver. Containers on the same bridge network can communicate with each other directly.
2. Host Network: Removes network isolation between the container and the Docker host, using the host’s network directly.
3. Overlay Network: Used for multi-host networking, allowing containers running on different Docker hosts to communicate.

Creating and Using Custom Networks:

# Create a user-defined bridge network
docker network create my-bridge-network

# Run a container on the custom network
docker run -d --name redis-server --network my-bridge-network redis

# Inspect the network
docker network inspect my-bridge-network






Docker Compose
Understanding Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you use a YAML file to configure your application's services, networks, and volumes.

Example docker-compose.yml file:

version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  redis:
    image: redis
    ports:
      - "6379:6379"

Using Docker Compose:

# Start the application defined in docker-compose.yml
docker-compose up -d

# View the running services
docker-compose ps

# Stop the application
docker-compose down









Docker Security
Best Practices for Securing Docker Containers

1. Use Official Images: Always use official images from trusted sources.
2. Least Privilege: Run containers with the least privileges required.
3. Use Docker Secrets: Store sensitive data like passwords and API keys securely.

Using Docker Secrets:

# Create a secret
echo "mysecretpassword" | docker secret create db_password -

# Use the secret in a service
docker service create --name my-app --secret db_password my-image

# List secrets
docker secret ls

# Remove a secret
docker secret rm db_password



Docker Volumes
Understanding Docker Volumes

Docker volumes are used to persist data generated by and used by Docker containers. Volumes are stored on the host filesystem outside of the container's filesystem.

Creating and Using Docker Volumes:

# Create a volume
docker volume create my-volume

# Run a container with a volume
docker run -d --name my-container -v my-volume:/data my-image

# Inspect the volume
docker volume inspect my-volume

# Remove a volume
docker volume rm my-volume





Advanced Dockerfile Techniques
Multi-Stage Builds

Multi-stage builds allow you to use multiple FROM statements in your Dockerfile, reducing the size of the final image by copying only the necessary artifacts.

Example Dockerfile with Multi-Stage Build:

# Stage 1: Build the application
FROM golang:1.16 as builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Create the final image
FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/myapp .
CMD ["./myapp"]

Best Practices for Writing Efficient Dockerfiles:

1. Use .dockerignore: Similar to .gitignore, this file excludes files and directories from the build context.
2. Minimize Layers: Combine RUN statements to reduce the number of layers.
3. Use Multi-Stage Builds: As shown above, this helps to keep the final image size small.

Example .dockerignore file:

node_modules
Dockerfile
.dockerignore
.git
README.md




Docker Swarm
Introduction to Docker Swarm

Docker Swarm is a native clustering and orchestration tool for Docker. It allows you to manage a cluster of Docker nodes as a single virtual system.

Setting up a Docker Swarm Cluster:

# Initialize the Docker Swarm mode
docker swarm init --advertise-addr <MANAGER-IP>

# Add a worker node (run this command on the worker node)
docker swarm join --token <TOKEN> <MANAGER-IP>:2377

# View nodes in the Swarm
docker node ls

Creating and Managing Services:

# Create a service
docker service create --name my-web --replicas 3 -p 80:80 nginx

# List services
docker service ls

# Scale a service
docker service scale my-web=5

# Remove a service
docker service rm my-web


Docker Swarm - Real-World Use Cases
Real-World Use Cases for Docker Swarm

1. Load Balancing:
   - Docker Swarm provides built-in load balancing for services. When you create a service, Swarm automatically distributes incoming requests across the available replicas.

Example: Load Balancing with Docker Swarm

# Create a service with multiple replicas
docker service create --name my-web --replicas 3 -p 80:80 nginx

# Scale the service to add more replicas
docker service scale my-web=5

2. Failover:
   - Docker Swarm ensures high availability by automatically redistributing services in case of node failures. If a node fails, Swarm redeploys the affected containers to other healthy nodes.

Example: Failover with Docker Swarm

# Initialize Docker Swarm mode
docker swarm init --advertise-addr <MANAGER-IP>

# Create a service with multiple replicas
docker service create --name my-app --replicas 3 my-image

# Simulate node failure by stopping a node
docker node update --availability drain <NODE-ID>

# Swarm will automatically redistribute the replicas to healthy nodes















Real-World Use Cases and Examples
Real-World Use Cases

1. Continuous Integration and Delivery (CI/CD):
   - Use Docker to create isolated build environments.
   - Deploy applications in a consistent environment from development to production.

2. Microservices Architecture:
   - Run different services in separate containers.
   - Use Docker Compose or Kubernetes to manage microservices.

3. Data Science and Machine Learning:
   - Package and share data science projects with all dependencies.
   - Ensure reproducibility of experiments and models.

Example: CI/CD Pipeline with Docker

# Dockerfile for a Node.js application
FROM node:14
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 8080
CMD ["node", "server.js"]

# docker-compose.yml for setting up CI/CD pipeline
version: '3'
services:
  web:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/usr/src/app
    environment:
      - NODE_ENV=development





      Additional Security Practices
Advanced Security Practices

1. Resource Limits:
   - Limit the CPU and memory usage of containers.

# Run a container with resource limits
docker run -d --name my-container --memory="256m" --cpus="1" my-image

2. User Namespaces:
   - Use user namespaces to map container user to a non-root user on the host.

# Enable user namespaces (edit /etc/docker/daemon.json)
{
  "userns-remap": "default"
}

3. Seccomp Profiles:
   - Use seccomp profiles to restrict the system calls a container can make.

# Run a container with a custom seccomp profile
docker run -d --name my-container --security-opt seccomp=/path/to/seccomp/profile.json my-image

4. Regular Security Audits:
   - Regularly scan Docker images for vulnerabilities using tools like Clair or Trivy.

# Scan an image using Trivy
trivy image my-image



Docker Networking - Overlay Network Example
Understanding Docker Networks

Docker provides several networking options to allow containers to communicate with each other and with the outside world. The main types of Docker networks are:

1. Bridge Network: The default network driver. Containers on the same bridge network can communicate with each other directly.
2. Host Network: Removes network isolation between the container and the Docker host, using the host’s network directly.
3. Overlay Network: Used for multi-host networking, allowing containers running on different Docker hosts to communicate.

Creating and Using Custom Networks:

# Create a user-defined bridge network
docker network create my-bridge-network

# Run a container on the custom network
docker run -d --name redis-server --network my-bridge-network redis

# Inspect the network
docker network inspect my-bridge-network

Creating and Using an Overlay Network:

# Initialize Docker Swarm mode
docker swarm init --advertise-addr <MANAGER-IP>

# Create an overlay network
docker network create --driver overlay my-overlay-network

# Run a service on the overlay network
docker service create --name redis-service --network my-overlay-network redis

# Inspect the overlay network
docker network inspect my-overlay-network







Bridge Network Use Case: Suitable for local development and testing where containers need to communicate on the same host.
# Create a bridge network
docker network create my-bridge-network

# Run containers on the bridge network
docker run -d --name web-server --network my-bridge-network nginx
docker run -d --name db-server --network my-bridge-network mysql



Host Network Use Case: Ideal for performance-sensitive applications that need direct access to host network interfaces.
# Run container on the host network
docker run -d --name my-container --network host my-image






Overlay Network Use Case: Used for multi-host communication in Docker Swarm mode, suitable for distributed systems.
# Initialize Docker Swarm mode
docker swarm init --advertise-addr <MANAGER-IP>

# Create an overlay network
docker network create --driver overlay my-overlay-network

# Run a service on the overlay network
docker service create --name redis-service --network my-overlay-network redis





Operator Pattern:

Extend Kubernetes functionalities by creating custom controllers.

Writing and Using Kubernetes Operators:



# Example of a CustomResourceDefinition (CRD) for an Operator
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: myresources.mydomain.com
spec:
  group: mydomain.com
  names:
    kind: MyResource
    plural: myresources
  scope: Namespaced
  versions:
  - name: v1
    served: true
    storage: true



    Custom Resource Definitions (CRDs):

Creating and using CRDs to extend Kubernetes functionality.
# Define a custom resource
apiVersion: "stable.example.com/v1"
kind: CronTab
metadata:
  name: my-cron-object
spec:
  cronSpec: "* * * * */5"
  image: my-cron-image



  Common Issues and Solutions:

Swap Error:
# Disable swap and update fstab
sudo swapoff -a
sudo sed -i '/ swap / s/^/#/' /etc/fstab


Container Runtime Error:
# Fix container runtime issue
sudo rm /etc/containerd/config.toml
sudo systemctl restart containerd



Config Permission Issue:
# Fix config permission issue
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config






-Docker Container Architecture-
+-------------------------------------------------------+
|                     Docker Host                      |
|                                                       |
|  +---------------+  +---------------+  +------------+ |
|  |  Container 1  |  |  Container 2  |  | Container3 | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  | |    App    | |  | |    App    | |  | |  App   | | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  | |  Bins/Libs| |  | |  Bins/Libs| |  | |Bins/Lib| | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  +---------------+  +---------------+  +------------+ |
|                   Docker Engine                       |
+-------------------------------------------------------+

-Dockerfile Best Practices-
FROM node:14-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["npm", "start"]

-Sample CI/CD Pipeline-
# .gitlab-ci.yml
stages:
 - build
 - test
 - deploy

build:
 stage: build
 script:
   - docker build -t myapp .

test:
 stage: test
 script:
   - docker run myapp npm test

deploy:
 stage: deploy
 script:
   - docker push myapp

-Networking Troubleshooting-
# Inspect network
docker network inspect my_network

# Check container connectivity
docker exec -it container1 ping container2

# Restart Docker network
docker network prune

-Docker Build Debugging-
# Build with verbose output
docker build --progress plain .

# Inspect intermediate images
docker history myimage

# Shell into intermediate containers
docker run --rm -it myimage:intermediate /bin/

-Container Monitoring-
# View container logs
docker logs my_container

# Stream container metrics
docker stats

# Monitor with Prometheus
docker run -p 9090:9090 prom/prometheus

-Docker Content Trust-
# Enable content trust
export DOCKER_CONTENT_TRUST=1

# Sign images on pudocker push myimage

# Pull only signed images
docker pull myimage

-Docker Bench for Security-
# Run Docker Bench
docker run -it --net host --pid host --userns host --cap-add audit_control \
   -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
   -v /etc:/etc:ro \
   -v /usr/bin/docker-containerd:/usr/bin/docker-containerd:ro \
   -v /usr/bin/docker-runc:/usr/bin/docker-runc:ro \
   -v /usr/lib/systemd:/usr/lib/systemd:ro \
   -v /var/lib:/var/lib:ro \
   -v /var/run/docker.sock:/var/run/docker.sock:ro \
   --label docker_bench_security \
   docker/docker-bench-security

-RBAC Policies-
# Create role
docker role create developer --description "Dev access"

# Grant service access
docker role grant developer container.list --collection myapp

# Revoke access
docker role revoke developer container.list --collection myapp

-LAMP Containerization-
# docker-compose.yml
version: '3'
services:
 web:
   image: php:apache
   volumes:
     - ./app:/var/www/html
 db:
   image: mysql
   environment:
     MYSQL_ROOT_PASSWORD: secret
     MYSQL_DATABASE: myapp

-Microservices Architecture-
+-----+     +-------+     +---------+
| Web |---->| Auth  |---->| Payment |
+-----+     +-------+     +---------+
 |             |             |
 v             v             v
+-----+     +-------+     +---------+
| App |     | Order |     | Shipping|
+-----+     +-------+     +---------+

-ML Model Deployment-
FROM python:3.8
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY model.pkl .
COPY app.py .

EXPOSE 5000
CMD ["python","app.py"]















 Visual Aids (Diagrams, Flowcharts, Screenshots)
Architecture Diagram
Example 1: Docker Architecture Diagram
plaintext

+-------------------------------------------------------+
|                     Docker Host                      |
|                                                       |
|  +---------------+  +---------------+  +------------+ |
|  |  Container 1  |  |  Container 2  |  | Container3 | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  | |    App    | |  | |    App    | |  | |  App   | | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  | |  Bins/Libs| |  | |  Bins/Libs| |  | |Bins/Lib| | |
|  | +-----------+ |  | +-----------+ |  | +--------+ | |
|  +---------------+  +---------------+  +------------+ |
|                   Docker Engine                       |
+-------------------------------------------------------+

Example 2: Kubernetes Cluster Diagram
plaintext

+-------------------+      +-------------------+      +-------------------+
|   Master Node     |      |   Worker Node 1   |      |   Worker Node 2   |
|                   |      |                   |      |                   |
|  +-------------+  |      |  +-------------+  |      |  +-------------+  |
|  |  API Server |  |      |  |  Pod 1      |  |      |  |  Pod 3      |  |
|  +-------------+  |      |  +-------------+  |      |  +-------------+  |
|  |  Scheduler  |  |      |  |  Pod 2      |  |      |  |  Pod 4      |  |
|  +-------------+  |      |  +-------------+  |      |  +-------------+  |
|  |  Controller |  |      |                   |      |                   |
|  +-------------+  |      +-------------------+      +-------------------+
|  |  etcd       |  |
|  +-------------+  |
+-------------------+

Flowchart for Container Creation
Example 1: Docker Container Creation Flowchart
plaintext

1. Create Dockerfile
2. Build Docker image
   - docker build -t myapp .
3. Run Docker container
   - docker run -d --name myapp-container myapp
4. Verify container is running
   - docker ps

Example 2: Kubernetes Deployment Flowchart
plaintext

1. Create Deployment YAML file
2. Apply Deployment YAML file
   - kubectl apply -f deployment.yaml
3. Expose Deployment
   - kubectl expose deployment myapp --port=80 --type=NodePort
4. Verify Deployment and Service
   - kubectl get deployments
   - kubectl get services

2. Detailed Explanations and Context
Example 1: Docker Container Creation with Detailed Explanation
plaintext

# Create a Dockerfile
# FROM specifies the base image
FROM node:14

# WORKDIR sets the working directory inside the container
WORKDIR /app

# COPY copies files from the host to the container
COPY package*.json ./

# RUN executes commands inside the container
RUN npm install

# COPY the rest of the application files
COPY . .

# EXPOSE specifies the port the container listens on
EXPOSE 3000

# CMD specifies the command to run when the container starts
CMD ["node", "app.js"]

# Build the Docker image
docker build -t myapp .

# Run the Docker container
docker run -d --name myapp-container -p 3000:3000 myapp

Example 2: Kubernetes Deployment with Detailed Explanation
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 3000

# Apply the deployment
kubectl apply -f deployment.yaml

# Expose the deployment as a service
kubectl expose deployment myapp --type=NodePort --port=3000

# Verify the deployment and service
kubectl get deployments
kubectl get services

3. Security Best Practices
Example 1: Image Scanning with Trivy


# Install Trivy
sudo apt-get install trivy

# Scan Docker image for vulnerabilities
trivy image myapp:latest

Example 2: Implementing Pod Security Policies
YAML

# psp.yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - ALL
  runAsUser:
    rule: MustRunAsNonRoot
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: MustRunAs
    ranges:
    - min: 1
      max: 65535
  fsGroup:
    rule: MustRunAs
    ranges:
    - min: 1
      max: 65535

# Apply the Pod Security Policy
kubectl apply -f psp.yaml

4. Advanced Networking Configurations
Example 1: Multi-Host Networking with Overlay Network


# Initialize Docker Swarm
docker swarm init --advertise-addr <MANAGER-IP>

# Create an overlay network
docker network create --driver overlay my-overlay-network

# Deploy a service on the overlay network
docker service create --name myapp --network my-overlay-network myapp:latest

Example 2: Kubernetes Network Policies
YAML

# Allow traffic from specific pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-specific
spec:
  podSelector:
    matchLabels:
      app: myapp
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 80

# Apply the Network Policy
kubectl apply -f allow-specific.yaml

5. CI/CD Integration
Example 1: Jenkins Pipeline for Docker and Kubernetes
Groovy

pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                script {
                    docker.build('myapp')
                }
            }
        }
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    kubernetesDeploy(
                        configs: 'deployment.yaml',
                        kubeconfigId: 'kubeconfig'
                    )
                }
            }
        }
    }
}

Example 2: GitLab CI/CD for Docker and Kubernetes
YAML

stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build -t myapp .
    - docker tag myapp registry.example.com/myapp:latest
    - docker push registry.example.com/myapp:latest

deploy:
  stage: deploy
  script:
    - kubectl apply -f deployment.yaml

6. Monitoring and Logging
Example 1: Setting Up Prometheus for Monitoring


# Create a namespace for monitoring
kubectl create namespace monitoring

# Install Prometheus using Helm
helm install prometheus prometheus-community/prometheus --namespace monitoring

# Verify Prometheus installation
kubectl get pods -n monitoring

Example 2: Setting Up ELK Stack for Logging


# Create a namespace for logging
kubectl create namespace logging

# Deploy Elasticsearch
kubectl apply -f https://download.elastic.co/downloads/eck/1.6.0/all-in-one.yaml

# Deploy Kibana
kubectl apply -f https://raw.githubusercontent.com/elastic/cloud-on-k8s/master/config/samples/kibana/kibana.yaml

# Verify ELK stack installation
kubectl get pods -n logging

7. Real-World Use Cases and Examples
Example 1: Microservices Architecture with Docker Compose
YAML

version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  api:
    image: myapi
    ports:
      - "3000:3000"
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example

Example 2: E-commerce Application with Kubernetes
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: frontend:latest
        ports:
        - containerPort: 80

# Apply the deployment
kubectl apply -f deployment.yaml

8. Troubleshooting and Debugging
Example 1: Debugging Docker Containers


# Check container logs
docker logs myapp-container

# Access container shell
docker exec -it myapp-container /bin/

Example 2: Debugging Kubernetes Pods


# Check pod logs
kubectl logs myapp-pod

# Access pod shell
kubectl exec -it myapp-pod -- /bin/

9. Performance Optimization
Example 1: Docker Resource Limits


# Run container with CPU and memory limits
docker run -d --name myapp-container --cpus="1.5" --memory="512m" myapp

Example 2: Kubernetes Resource Requests and Limits
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        resources:
          requests:
            memory: "256Mi"
            cpu: "500m"
          limits:
            memory: "512Mi"
            cpu: "1"

10. Multi-Tenancy and Scalability
Example 1: Horizontal Pod Autoscaling (HPA)
YAML

# Create HPA for myapp
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50

# Apply the HPA
kubectl apply -f hpa.yaml

Example 2: Vertical Pod Autoscaling (VPA)
YAML

# Create VPA for myapp
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: myapp-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment
    name:       myapp
  updatePolicy:
    updateMode: "Auto"

# Apply the VPA
kubectl apply -f vpa.yaml

This document provides comprehensive examples and explanations for each of the missing or underdeveloped sections, enhancing the overall quality and usefulness of the Docker and Kubernetes documentation.












Enhancing Docker and Kubernetes Documentation

This document addresses the missing or underdeveloped sections in the existing Docker and Kubernetes documentation. Each section includes detailed explanations and two code examples to provide a comprehensive understanding of the topic.
1. Visual Aids (Diagrams, Flowcharts, Screenshots)
Diagram for Multi-Container Orchestration
Example 1: Docker Compose Multi-Container Orchestration Diagram
plaintext

+--------------------+
| Docker Host        |
|                    |
| +----------------+ |
| |  Web Service   | |
| +----------------+ |
| |  API Service   | |
| +----------------+ |
| |  DB Service    | |
| +----------------+ |
+--------------------+

Example 2: Kubernetes Multi-Container Orchestration Diagram
plaintext

+--------------------+
| Kubernetes Cluster |
|                    |
| +----------------+ |
| |  Web Pod       | |
| +----------------+ |
| |  API Pod       | |
| +----------------+ |
| |  DB Pod        | |
| +----------------+ |
+--------------------+

Flowchart for CI/CD Pipeline
Example 1: CI/CD Pipeline with Jenkins
plaintext

1. Developer commits code to repository
2. Jenkins triggers build pipeline
3. Build Docker image
   - docker build -t myapp .
4. Push Docker image to registry
   - docker push myapp:latest
5. Deploy to Kubernetes
   - kubectl apply -f deployment.yaml

Example 2: CI/CD Pipeline with GitLab CI
plaintext

1. Developer commits code to repository
2. GitLab CI triggers pipeline
3. Build Docker image
   - docker build -t myapp .
4. Push Docker image to registry
   - docker push myapp:latest
5. Deploy to Kubernetes
   - kubectl apply -f deployment.yaml

2. Detailed Explanations and Context
Example 1: Differences Between Docker and Kubernetes in CI/CD Pipeline

    Docker: Used to build and package applications into containers.
    Kubernetes: Manages and scales the deployment of these containers across a cluster, ensuring high availability and fault tolerance.

Example 2: Real-World Scenario for Docker and Kubernetes

    Scenario: Deploying a microservices application with multiple services (web, API, and database) using Docker for containerization and Kubernetes for orchestration.
    Configuration:

YAML

# docker-compose.yml
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  api:
    image: myapi
    ports:
      - "3000:3000"
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web
        image: nginx
        ports:
        - containerPort: 80

3. Security Best Practices
Example 1: Secure Configuration Management


# Use Docker secrets to manage sensitive data
echo "mysecretpassword" | docker secret create db_password -

# Use the secret in a Docker service
docker service create --name my-app --secret db_password my-image

Example 2: Runtime Security Practices
YAML

# Pod Security Policy in Kubernetes
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - ALL
  runAsUser:
    rule: MustRunAsNonRoot
  seLinux:
    rule: RunAsAny

# Apply the Pod Security Policy
kubectl apply -f psp.yaml

4. Advanced Networking Configurations
Example 1: Integrating Istio with Kubernetes


# Install Istio
istioctl install --set profile=demo

# Deploy a sample application with Istio sidecar injection
kubectl label namespace default istio-injection=enabled
kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml

Example 2: Multi-Host Networking with Overlay Network


# Initialize Docker Swarm
docker swarm init --advertise-addr <MANAGER-IP>

# Create an overlay network
docker network create --driver overlay my-overlay-network

# Deploy a service on the overlay network
docker service create --name myapp --network my-overlay-network myapp:latest

5. CI/CD Integration
Example 1: CircleCI Integration with Docker and Kubernetes
YAML

# .circleci/config.yml
version: 2.1
jobs:
  build:
    docker:
      - image: circleci/python:3.8
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker image
          command: docker build -t myapp .
      - run:
          name: Push Docker image
          command: docker push myapp:latest
      - run:
          name: Deploy to Kubernetes
          command: kubectl apply -f deployment.yaml
workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build

Example 2: Travis CI Integration with Docker and Kubernetes
YAML

# .travis.yml
language: python
services:
  - docker
before_install:
  - docker build -t myapp .
  - docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"
script:
  - docker push myapp:latest
  - kubectl apply -f deployment.yaml

1 vulnerability detected

6. Monitoring and Logging
Example 1: Setting Up Fluentd for Log Aggregation


# Create a namespace for logging
kubectl create namespace logging

# Deploy Fluentd
kubectl apply -f https://raw.githubusercontent.com/fluent/fluentd-kubernetes-daemonset/master/fluentd-daemonset-elasticsearch-rbac.yaml

Example 2: Setting Up Alerting with Prometheus and Alertmanager
YAML

# alertmanager-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-config
  namespace: monitoring
data:
  alertmanager.yml: |-
    global:
      resolve_timeout: 5m
    route:
      receiver: "email"
    receivers:
    - name: "email"
      email_configs:
      - to: "your-email@example.com"
        from: "alertmanager@example.com"
        smarthost: "smtp.example.com:587"
        auth_username: "alertmanager"
        auth_password: "your-password"

# Apply the Alertmanager configuration
kubectl apply -f alertmanager-config.yaml

7. Real-World Use Cases and Examples
Example 1: Deploying a Machine Learning Model with Docker
Python

# Dockerfile
FROM python:3.8-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]

# Build and run the Docker container
docker build -t ml-model .
docker run -d -p 5000:5000 ml-model

Example 2: Large-Scale Data Processing with Kubernetes
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: data-processor
spec:
  replicas: 5
  selector:
    matchLabels:
      app: data-processor
  template:
    metadata:
      labels:
        app: data-processor
    spec:
      containers:
      - name: data-processor
        image: data-processor:latest
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"

8. Troubleshooting and Debugging
Example 1: Step-by-Step Troubleshooting Guide for Docker


# Check container logs
docker logs myapp-container

# Inspect container
docker inspect myapp-container

# Access container shell
docker exec -it myapp-container /bin/

Example 2: Advanced Debugging Techniques for Kubernetes


# Check pod logs
kubectl logs myapp-pod

# Describe pod for detailed information
kubectl describe pod myapp-pod

# Access pod shell
kubectl exec -it myapp-pod -- /bin/

9. Performance Optimization
Example 1: Best Practices for Optimizing Docker Images


# Use multistage builds in Dockerfile
# Stage 1: Build the application
FROM golang:1.16 as builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Create the final image
FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/myapp .
CMD ["./myapp"]

Example 2: Resource Management in Kubernetes
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        resources:
          requests:
            memory: "256Mi"
            cpu: "500m"
          limits:
            memory: "512Mi"
            cpu: "1"

10. Multi-Tenancy and Scalability
Example 1: Implementing Multi-Tenancy in Kubernetes


# Create namespaces for different tenants
kubectl create namespace tenant1
kubectl create namespace tenant2

# Deploy applications in each namespace
kubectl apply -f tenant1-deployment.yaml -n tenant1
kubectl apply -f tenant2-deployment.yaml -n tenant2

Example 2: Using Horizontal and Vertical Pod Autoscalers
YAML

# Create HPA for myapp
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50

# Apply the HPA
kubectl apply -f hpa.yaml

# Create VPA for myapp
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: myapp-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment
    name:       myapp
  updatePolicy:
    updateMode: "Auto"

# Apply the VPA
kubectl apply -f vpa.yaml

This document provides comprehensive examples and explanations for each of the missing or underdeveloped sections, enhancing the overall quality and usefulness of the Docker and Kubernetes documentation.












Detailed Explanations and Context
Example 1: Differences Between Docker and Kubernetes Roles in a CI/CD Pipeline

Docker is used to build and package applications into containers, while Kubernetes manages and scales the deployment of these containers across a cluster, ensuring high availability and fault tolerance.
Example 2: Real-World Scenario for Docker and Kubernetes
Scenario: Deploying a Microservices Application

    Docker: Containerizes each service (e.g., web, API, database).
    Kubernetes: Orchestrates the deployment and scaling of these services.

YAML

# docker-compose.yml
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  api:
    image: myapi
    ports:
      - "3000:3000"
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web
        image: nginx
        ports:
        - containerPort: 80

3. Security Best Practices
Example 1: Secure Configuration Management


# Use Docker secrets to manage sensitive data
echo "mysecretpassword" | docker secret create db_password -

# Use the secret in a Docker service
docker service create --name my-app --secret db_password my-image

Example 2: Runtime Security Practices
YAML

# Pod Security Policy in Kubernetes
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - ALL
  runAsUser:
    rule: MustRunAsNonRoot
  seLinux:
    rule: RunAsAny

# Apply the Pod Security Policy
kubectl apply -f psp.yaml

4. Advanced Networking Configurations
Example 1: Integrating Istio with Kubernetes


# Install Istio
istioctl install --set profile=demo

# Deploy a sample application with Istio sidecar injection
kubectl label namespace default istio-injection=enabled
kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml

Example 2: Multi-Host Networking with Overlay Network


# Initialize Docker Swarm
docker swarm init --advertise-addr <MANAGER-IP>

# Create an overlay network
docker network create --driver overlay my-overlay-network

# Deploy a service on the overlay network
docker service create --name myapp --network my-overlay-network myapp:latest

5. CI/CD Integration
Example 1: CircleCI Integration with Docker and Kubernetes
YAML

# .circleci/config.yml
version: 2.1
jobs:
  build:
    docker:
      - image: circleci/python:3.8
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker image
          command: docker build -t myapp .
      - run:
          name: Push Docker image
          command: docker push myapp:latest
      - run:
          name: Deploy to Kubernetes
          command: kubectl apply -f deployment.yaml
workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build

Example 2: Travis CI Integration with Docker and Kubernetes
YAML

# .travis.yml
language: python
services:
  - docker
before_install:
  - docker build -t myapp .
  - docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"
script:
  - docker push myapp:latest
  - kubectl apply -f deployment.yaml

6. Monitoring and Logging
Example 1: Setting Up Fluentd for Log Aggregation


# Create a namespace for logging
kubectl create namespace logging

# Deploy Fluentd
kubectl apply -f https://raw.githubusercontent.com/fluent/fluentd-kubernetes-daemonset/master/fluentd-daemonset-elasticsearch-rbac.yaml

Example 2: Setting Up Alerting with Prometheus and Alertmanager
YAML

# alertmanager-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-config
  namespace: monitoring
data:
  alertmanager.yml: |-
    global:
      resolve_timeout: 5m
    route:
      receiver: "email"
    receivers:
    - name: "email"
      email_configs:
      - to: "your-email@example.com"
        from: "alertmanager@example.com"
        smarthost: "smtp.example.com:587"
        auth_username: "alertmanager"
        auth_password: "your-password"

# Apply the Alertmanager configuration
kubectl apply -f alertmanager-config.yaml

7. Real-World Use Cases and Examples
Example 1: Deploying a Machine Learning Model with Docker
Python

# Dockerfile
FROM python:3.8-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]

# Build and run the Docker container
docker build -t ml-model .
docker run -d -p 5000:5000 ml-model

Example 2: Large-Scale Data Processing with Kubernetes
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: data-processor
spec:
  replicas: 5
  selector:
    matchLabels:
      app: data-processor
  template:
    metadata:
      labels:
        app: data-processor
    spec:
      containers:
      - name: data-processor
        image: data-processor:latest
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"

8. Troubleshooting and Debugging
Example 1: Step-by-Step Troubleshooting Guide for Docker


# Check container logs
docker logs myapp-container

# Inspect container
docker inspect myapp-container

# Access container shell
docker exec -it myapp-container /bin/

Example 2: Advanced Debugging Techniques for Kubernetes


# Check pod logs
kubectl logs myapp-pod

# Describe pod for detailed information
kubectl describe pod myapp-pod

# Access pod shell
kubectl exec -it myapp-pod -- /bin/

9. Performance Optimization
Example 1: Best Practices for Optimizing Docker Images


# Use multistage builds in Dockerfile
# Stage 1: Build the application
FROM golang:1.16 as builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Create the final image
FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/myapp .
CMD ["./myapp"]

Example 2: Resource Management in Kubernetes
YAML

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        resources:
          requests:
            memory: "256Mi"
            cpu: "500m"
          limits:
            memory: "512Mi"
            cpu: "1"

10. Multi-Tenancy and Scalability
Example 1: Implementing Multi-Tenancy in Kubernetes


# Create namespaces for different tenants
kubectl create namespace tenant1
kubectl create namespace tenant2

# Deploy applications in each namespace
kubectl apply -f tenant1-deployment.yaml -n tenant1
kubectl apply -f tenant2-deployment.yaml -n tenant2

Example 2: Using Horizontal and Vertical Pod Autoscalers
YAML

# Create HPA for myapp
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50

# Apply the HPA
kubectl apply -f hpa.yaml

# Create VPA for myapp
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: myapp-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment
    name:       myapp
  updatePolicy:
    updateMode: "Auto"

# Apply the VPA
kubectl apply -f vpa.yaml












Lab 1: Basic Docker Container Management
Objectives:

    Understand how to create, run, and manage Docker containers.
    Learn how to use Docker commands to interact with containers.

Steps:

    Install Docker:


sudo apt update
sudo apt install -y ca-certificates curl gnupg lsb-release
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo usermod -aG docker $USER
newgrp docker
docker run hello-world

Public code references from 5 repositories

Run Redis and ArangoDB Containers:


docker run -d --name redis-server -p 6379:6379 redis
docker run -d --name arangodb-server -p 8529:8529 arangodb

Public code references from 4 repositories

List Running Containers:


docker ps

Inspect a Specific Container:


docker inspect redis-server

Public code references from 4 repositories

Stop and Remove Containers:


docker stop redis-server arangodb-server
docker rm redis-server arangodb-server

Public code references from 4 repositories

Lab 2: Building and Running Docker Images
Objectives:

    Learn how to write a Dockerfile.
    Build and run Docker images from a Dockerfile.

Steps:

    Create a Dockerfile for a Simple Node.js Application:
    Dockerfile

# Dockerfile
FROM node:14
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]

Public code references from 1 repository

Build the Docker Image:


docker build -t mynodeapp .

Public code references from 1 repository

Run the Docker Container:


docker run -d --name mynodeapp-container -p 3000:3000 mynodeapp

Verify the Container is Running:


    docker ps

    Access the Application in a Browser:
        Open a web browser and navigate to http://localhost:3000.

Lab 3: Deploying Applications with Kubernetes
Objectives:

    Learn how to create and manage Kubernetes deployments and services.
    Understand how to scale applications with Kubernetes.

Steps:

    Install Kubernetes Components:


sudo apt update
sudo apt install -y apt-transport-https curl
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list
sudo apt update
sudo apt install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl

Public code references from 1 repository

Initialize Kubernetes Cluster:


sudo kubeadm init --pod-network-cidr=10.244.0.0/16
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

Public code references from 1 repository

Create and Expose a Deployment:


kubectl create deployment nginx --image=nginx
kubectl expose deployment nginx --port=80 --type=NodePort

Public code references from 8 repositories

Scale the Deployment:


kubectl scale deployment nginx --replicas=3

Public code references from 8 repositories

Verify the Deployment and Service:


    kubectl get deployments
    kubectl get services

Lab 4: CI/CD Integration with Docker and Kubernetes
Objectives:

    Learn how to set up a CI/CD pipeline using CircleCI or Travis CI.
    Automate the deployment of Docker containers to a Kubernetes cluster.

Steps:

    Create a .circleci/config.yml for CircleCI:
    YAML

version: 2.1
jobs:
  build:
    docker:
      - image: circleci/python:3.8
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker image
          command: docker build -t myapp .
      - run:
          name: Push Docker image
          command: docker push myapp:latest
      - run:
          name: Deploy to Kubernetes
          command: kubectl apply -f deployment.yaml
workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build

Public code references from 1 repository

Create a .travis.yml for Travis CI:
YAML

language: python
services:
  - docker
before_install:
  - docker build -t myapp .
  - docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"
script:
  - docker push myapp:latest
  - kubectl apply -f deployment.yaml

Public code references from 1 repository

Push the Configuration Files to Your Repository:


git add .circleci/config.yml .travis.yml
git commit -m "Add CI/CD pipeline configuration"
git push origin main

Public code references from 1 repository

    Monitor the CI/CD Pipeline in CircleCI or Travis CI Dashboard.

Lab 5: Monitoring and Logging with Kubernetes
Objectives:

    Learn how to set up monitoring and logging for Kubernetes clusters.
    Use Prometheus and Fluentd for collecting metrics and logs.

Steps:

    Create a Namespace for Monitoring:


kubectl create namespace monitoring

Install Prometheus using Helm:


helm install prometheus prometheus-community/prometheus --namespace monitoring

Verify Prometheus Installation:


kubectl get pods -n monitoring

Set Up Fluentd for Log Aggregation:


kubectl create namespace logging
kubectl apply -f https://raw.githubusercontent.com/fluent/fluentd-kubernetes-daemonset/master/fluentd-daemonset-elasticsearch-rbac.yaml

Public code references from 1 repository

Access Prometheus and Fluentd Dashboards:

    Use port forwarding to access Prometheus:


kubectl port-forward service/prometheus-server 8080:80 -n monitoring

Use port forwarding to access Fluentd (if applicable):


kubectl port-forward service/fluentd 24224:24224 -n logging



By completing these labs, you will gain hands-on experience with Docker and Kubernetes, including container management, image building, deployment, CI/CD integration, and monitoring/logging.























Prerequisites and Setup

Before diving into Docker, ensure you have:

    Basic command-line interface knowledge
    Fundamental programming understanding
    A modern computer (8GB+ RAM)
    Stable internet connection

Installation and Verification: Three Approaches
1. Ubuntu Installation Method

    Update system packages
sudo apt update

Install required dependencies
 sudo apt install -y apt-transport-https ca-certificates curl software-properties-common

Add Docker's official GPG key
 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

Set up stable repository
 sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

Install Docker
 sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io

Add current user to docker group


sudo usermod -aG docker $USER

Verify installation
     docker --version
    docker run hello-world

2. MacOS Installation (Homebrew)

    Install Docker Desktop via Homebrew


brew install --cask docker

Verify installation
     docker --version
    docker run hello-world

3. Windows Installation (WSL2)

    Enable WSL2 feature


dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

Download and install Docker Desktop for Windows

    Visit the official Docker website and download the installer.

Verify installation


    docker --version
    docker run hello-world

Practical Learning Path: Hands-On Examples

1. Understanding Container Basics
Example 1: Simple Web Server Container

    Pull nginx image
     docker pull nginx

Run nginx container
 docker run -d -p 8080:80 --name web-server nginx

Verify container is running
 docker ps
Access in browser: http://localhost:8080





Example 2: Python Flask Application

    Create a Dockerfile
    plaintext

FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]

Create app.py
Python

from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Docker is awesome!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

Create requirements.txt

flask

Build and run Flask container
     docker build -t flask-app .
    docker run -p 5000:5000 flask-app

Example 3: Container Lifecycle Management

    List all containers
     docker ps -a

Stop a running container
 docker stop web-server

Remove a container
 docker rm web-server

Remove an image
     docker rmi nginx






2. Building Your First Container
Example 1: Node.js Application

    Create a Dockerfile for Node.js app
    plaintext

FROM node:14
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]

Create package.json
JSON

{
  "name": "docker-demo",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.17.1"
  }
}

Create server.js
JavaScript

const express = require('express');
const app = express();
const PORT = 3000;

app.get('/', (req, res) => {
  res.send('Containerized Node.js Application');
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

Build and run Node.js container


    docker build -t node-app .
    docker run -p 3000:3000 node-app







Example 2: Multi-Stage Build

    Create a Dockerfile for Go application
    plaintext

# Build stage
FROM golang:1.16 AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o myapp

# Production stage
FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/myapp .
CMD ["./myapp"]

Build and run Go application container


    docker build -t go-app .
    docker run go-app

Example 3: Docker Compose for Multiple Services

    Create a docker-compose.yml file
    YAML

version: '3'
services:
  web:
    build: ./web
    ports:
      - "5000:5000"
  database:
    image: postgres:12
    environment:
      POSTGRES_PASSWORD: example

Build and run services with Docker Compose


    docker-compose up









3. Advanced Containerization
Example 1: Docker Networking

    Create custom bridge network


docker network create my-network

Run containers on custom network


    docker run -d --name db --network my-network postgres
    docker run -d --name app --network my-network -e DB_HOST=db myapp

Example 2: Volume Management

    Create a named volume


docker volume create mydata

Mount volume to container


docker run -v mydata:/data myapp

Backup volume


    docker run --rm -v mydata:/data -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /data

Example 3: Docker Swarm Deployment

    Initialize Docker Swarm


docker swarm init

Create a service


docker service create --replicas 3 --name web nginx

Scale service


docker service scale web=5

Update service


    docker service update --image nginx:latest web

Security and Performance Optimization
Best Practices Code Examples
Security Scanning

    Scan Docker images for vulnerabilities


docker scan myimage

Use Trivy for comprehensive scanning


    trivy image myimage

Resource Management

    Limit container resources


docker run --cpus=1.5 --memory=512m myapp

Set resource constraints in Compose
YAML

services:
  myapp:
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M












