-----FirewallD Comprehensive Reference Guide----


Use firewall-config for exam, as graphical interface!!






This  guide provides an exhaustive exploration of FirewallD network security management for system
administrators and security professionals.



Table of Contents

    Introduction
        What is FirewallD?
        Key Features

    Architecture and Components
        FirewallD and the Linux Network Stack
        FirewallD Services
        FirewallD Configuration Files

    Installation and Configuration
        Installing FirewallD
        Configuring FirewallD
        Checking FirewallD Status

    Core Command Structure
        Basic Syntax
        Common Options

    Basic Firewall Management
        Status and Information Commands

    Zones
        Predefined Zones
        Custom Zones
        Configuring Zones
        Multi-Environment Network Setup

    Services and Ports
        Predefined Services
        Custom Services
        Port Configuration

    Rich Rules
        Rich Rule Syntax
        Creating Rich Rules
        Advanced Traffic Control
        Example Rich Rules

    Direct Rules
        Direct Rule Syntax
        Creating Direct Rules

    Integration with NFTables
        How FirewallD Uses NFTables
        Translating iptables Rules

    Troubleshooting
        Diagnostic Flowchart
        Common Issues
        Error Handling Matrix
        Debugging with FirewallD
        Analyzing Logs

    Security Optimization
        Advanced Security Hardening

    Scripting and Automation
        Comprehensive Firewall Configuration Script
        FirewallD D-Bus API
        Python FirewallD Bindings
        Ansible Firewall Modules

    Best Practices and Recommendations
        Key Takeaways
        Compatibility
        Recommended Resources

    Migrating from iptables
        Comparing FirewallD to iptables
        Converting iptables Rules

    Conclusion
    References








1. Introduction
1.1. What is FirewallD?

FirewallD is a dynamic firewall management tool designed for Linux operating systems. It provides a
powerful and flexible framework for defining and enforcing network traffic rules. FirewallD operates as
a front-end controller for the Linux kernelâ€™s Netfilter framework. It allows administrators to define
firewall policies using a higher-level, zone-based approach, abstracting the complexity of direct
iptables manipulation.




Key advantages of FirewallD include:

    Dynamic rule and policy management
    Support for network zones
    Simplified syntax compared to iptables
    Integration with NetworkManager
    Persistent and runtime configurations







FirewallD is the default firewall management tool on many Linux distributions, including Red Hat
Enterprise Linux, Fedora, CentOS, and more.




1.2. Key Features

Flexible Network Traffic Control:

    Granular control over incoming and outgoing network traffic
    Dynamic rule modification without disrupting existing connections
    Supports immediate and persistent configuration changes

Zone-Based Configuration:

    Logical network zones with predefined and custom rulesets
    Simplified management of different network environments
    Easy-to-understand security segmentation

Runtime and Permanent Configuration:

    Immediate rule application
    Persistent configuration across system reboots
    Seamless integration with system networking

Simplified Security Administration:

    Intuitive command-line interface
    Reduced complexity compared to traditional iptables
    Powerful yet user-friendly management








2. Architecture and Components
2.1. FirewallD and the Linux Network Stack
Code

+-------------+
|  FirewallD  |
+-------------+
     |
     v
+--------------------------------------+
|             Linux Kernel             |
|--------------------------------------|
|  +----------------+  +----------+    |
|  |   Conntrack    |  | Netfilter |    |
|  +----------------+  +----------+    |
|          ^                         |
|          |                         |
|      Packet Flow                   |
+--------------------------------------+






FirewallD operates at the user-space level, acting as a controller and interface for configuring the
kernel-space Netfilter hooks. Here's a breakdown of the components:

    FirewallD: The FirewallD daemon runs in user-space and provides the management interface for
    configuring firewall rules and policies. Administrators interact with FirewallD through its command
    line client firewall-cmd, configuration files, or D-Bus API.
    Netfilter: Netfilter is a framework inside the Linux kernel that enables packet filtering, network
    address translation (NAT), and other packet mangling. It provides a set of hooks at various points
    in the network stack where packet inspection and manipulation can occur.
    Conntrack: Connection tracking (conntrack) is a Netfilter module that keeps track of the state of
    network connections and sessions traveling through the system. It enables stateful inspection of
    packets, allowing the firewall to make decisions based on the connection context.






When a packet enters the Linux network stack:

    The packet first hits the Netfilter hooks in the kernel-space.
    Conntrack examines the packet and associates it with a new or existing connection in its state
    table.
    The packet then passes through the various Netfilter hooks where it is inspected against the rules
    defined by FirewallD.
    Based on these rules, the packet is accepted, dropped, rejected, or manipulated.
    If accepted, the packet continues to its intended destination.








FirewallD's primary role is to provide a user-friendly abstraction over these kernel-space components.
It allows defining rules and policies in a higher-level language which are then translated to the
underlying Netfilter rules.





















Firewalld is a dynamic firewall management tool that supports different firewall zones. Each zone has a predefined set of rules that dictate the trust level of network connections. Here is a detailed explanation of each zone:

1. Trusted Zone

    Description: This zone is the least restrictive. It allows all incoming traffic without any filtering.
    Use Case: Use this zone for networks that you fully trust, such as a home network where you control all the devices.
    Rules: All incoming traffic is accepted.

2. Home Zone

    Description: This zone is designed for home use. It rejects incoming traffic unless it is related to outgoing traffic or matches specific types of traffic.
    Use Case: Ideal for home networks where you want some level of security but still allow common services and related traffic.
    Rules:
        Rejects all incoming traffic by default.
        Allows incoming traffic that is related to outgoing traffic (stateful inspection).
        Allows specific types of traffic such as DHCP, mDNS, etc.

3. Internal Zone

    Description: This zone is used for internal networks. It provides a higher level of trust than the public zone but is more restrictive than the home zone.
    Use Case: Suitable for internal networks within an organization where you want to allow more services but still limit exposure.
    Rules:
        Rejects all incoming traffic by default.
        Allows specific services and types of traffic that are typically used within an internal network.

4. Work Zone

    Description: This zone is intended for use in work environments. It is similar to the internal zone but may have different rules based on organizational policies.
    Use Case: Use this zone for work networks where you need to allow certain services and maintain a balance between security and functionality.
    Rules:
        Rejects all incoming traffic by default.
        Allows specific services and types of traffic typically used in a work environment.

5. Public Zone

    Description: This zone is used for public networks, such as those found in coffee shops or airports. It provides a higher level of security by limiting incoming traffic.
    Use Case: Ideal for use in public Wi-Fi hotspots where you want to protect your device from potential threats.
    Rules:
        Rejects all incoming traffic by default.
        Allows specific types of traffic that are deemed safe for public networks.

6. External Zone

    Description: This zone is intended for use with external networks, such as the internet. It is highly restrictive to protect your device from external threats.
    Use Case: Use this zone for connections to the internet or other untrusted external networks.
    Rules:
        Rejects all incoming traffic by default.
        Allows specific types of traffic that are explicitly permitted.

7. DMZ (Demilitarized Zone)

    Description: This zone is used for servers that need to be accessible from external networks but still require some level of protection.
    Use Case: Suitable for web servers, mail servers, and other public-facing services that need to be accessible from the internet.
    Rules:
        Rejects all incoming traffic by default.
        Allows specific services and types of traffic required for the public-facing services.

8. Block Zone

    Description: This zone is the most restrictive. It blocks all incoming and outgoing connections.
    Use Case: Use this zone to block all network traffic when you want to completely isolate a device from the network.
    Rules:
        Blocks all incoming and outgoing traffic.

9. Drop Zone

    Description: This zone drops all incoming connections without sending any response packets.
    Use Case: Use this zone when you want to silently drop all incoming traffic without informing the sender.
    Rules:
        Drops all incoming traffic.
        No response packets are sent (e.g., no ICMP unreachable messages).












































Unified Text Box on Firewalld and Related Tools

1. firewall-cmd

    Description: firewall-cmd is the command line interface for firewalld. It allows you to configure and manage firewall rules in a dynamic way without the need to restart the firewall.
    Usage Example:
    bash

    # List all zones
    firewall-cmd --get-zones

    # Add a rule to allow HTTP traffic in the public zone
    firewall-cmd --zone=public --add-service=http --permanent
    firewall-cmd --reload

2. ebtables

    Description: ebtables is a utility for managing Ethernet bridge firewall rules. It operates at the data link layer and is useful for managing filtering on bridges.
    Usage Example:
    bash

    # List all ebtables rules
    ebtables -L

    # Add a rule to drop all incoming traffic on br0
    ebtables -A INPUT -i br0 -j DROP

3. iptables

    Description: iptables is a user-space utility program that allows a system administrator to configure the IPv4 packet filtering and NAT rules of the Linux kernel firewall.
    Usage Example:
    bash

    # List all iptables rules
    iptables -L

    # Add a rule to drop all incoming traffic to port 80
    iptables -A INPUT -p tcp --dport 80 -j DROP

4. ip6tables

    Description: Similar to iptables, ip6tables is used to set up, maintain, and inspect the tables of IPv6 packet filter rules in the Linux kernel.
    Usage Example:
    bash

    # List all ip6tables rules
    ip6tables -L

    # Add a rule to drop all incoming traffic to port 80
    ip6tables -A INPUT -p tcp --dport 80 -j DROP

5. netfilter

    Description: netfilter is a framework provided by the Linux kernel that allows various networking-related operations to be implemented in the form of customized handlers. It provides functionalities like packet filtering, network address translation, and port translation.
    Usage Example:
    bash

    # netfilter is usually manipulated using tools like iptables or nftables

6. nftables

    Description: nftables is the successor to iptables and provides packet filtering, network address translation, and other packet mangling. It is intended to replace iptables, ip6tables, arptables, and ebtables.
    Usage Example:
    bash

    # List all nftables rules
    nft list ruleset

    # Add a rule to drop all incoming traffic to port 80
    nft add rule inet filter input tcp dport 80 drop

7. firewalld

    Description: firewalld is a firewall management tool available in many Linux distributions. It provides a dynamic way to manage the firewall with support for network zones to define trust levels for different network connections.
    Usage Example:
    bash

    # Start firewalld service
    systemctl start firewalld

    # Enable firewalld to start at boot
    systemctl enable firewalld

8. systemctl

    Description: systemctl is used to examine and control the systemd system and service manager. It is used to manage services such as firewalld.
    Usage Example:
    bash

    # Start firewalld service
    systemctl start firewalld

    # Check status of firewalld service
    systemctl status firewalld

9. tcpdump

    Description: tcpdump is a packet analyzer that allows the user to display TCP/IP and other packets being transmitted or received over a network.
    Usage Example:
    bash

    # Capture all packets on the network interface
    tcpdump -i eth0

    # Capture packets to and from a specific host
    tcpdump host 192.168.1.1

10. nmap

    Description: nmap (Network Mapper) is a network scanning tool used to discover hosts and services on a computer network by sending packets and analyzing the responses.
    Usage Example:
    bash

    # Scan a single IP address
    nmap 192.168.1.1

    # Scan a range of IP addresses
    nmap 192.168.1.1-255

11. ufw

    Description: ufw (Uncomplicated Firewall) is a user-friendly frontend for managing iptables firewall rules. It is designed to be easy to use for managing a host-based firewall.
    Usage Example:
    bash

    # Enable ufw
    ufw enable

    # Allow SSH connections
    ufw allow ssh

12. selinux

    Description: SELinux (Security-Enhanced Linux) is a security architecture integrated into the Linux kernel that provides access control security policies, including mandatory access control (MAC).
    Usage Example:
    bash

    # Check the current SELinux status
    sestatus

    # Change SELinux mode to permissive
    setenforce 0

13. auditd

    Description: auditd is the userspace component to the Linux Auditing System. It provides a framework for recording and analyzing security-relevant events.
    Usage Example:
    bash

    # Start the auditd service
    systemctl start auditd

    # Check the status of auditd service
    systemctl status auditd

14. logrotate

    Description: logrotate is a system utility that manages the automatic rotation and compression of log files, helping to manage disk space and keep logs organized.
    Usage Example:
    bash

# Manually rotate logs
logrotate /etc/logrotate.conf























Types of Network Traffic and Their Corresponding Layers/Zones

Networking traffic can be classified based on the type of service or protocol it uses. Below is a detailed explanation of the types of traffic, along with the layers and zones they typically operate in:

1. SSH (Secure Shell)

    Description: SSH is used for secure remote login and command execution.
    Port: TCP 22
    Layer: Application Layer
    Zones: Work, Internal, Public, Home

2. mDNS (Multicast DNS)

    Description: mDNS resolves hostnames to IP addresses within small networks without a local name server.
    Port: UDP 5353
    Layer: Application Layer
    Zones: Home, Internal

3. IPP (Internet Printing Protocol) Client

    Description: IPP is used for network printing services.
    Port: TCP 631
    Layer: Application Layer
    Zones: Work, Internal

4. Samba Client

    Description: Samba allows file and print sharing between computers running Windows and Unix.
    Ports: TCP 139, 445
    Layer: Application Layer
    Zones: Home, Work, Internal

5. DHCPv6 Client

    Description: DHCPv6 is used for assigning IP addresses and configuring other network settings for IPv6.
    Port: UDP 546
    Layer: Application Layer
    Zones: Home, Internal

Top 20 Most Common Types of Traffic

6. HTTP (Hypertext Transfer Protocol)

    Description: HTTP is used for transferring web pages and other content over the internet.
    Port: TCP 80
    Layer: Application Layer
    Zones: Public, Work, Home

7. HTTPS (Hypertext Transfer Protocol Secure)

    Description: HTTPS is the secure version of HTTP, using SSL/TLS to encrypt data.
    Port: TCP 443
    Layer: Application Layer
    Zones: Public, Work, Home

8. FTP (File Transfer Protocol)

    Description: FTP is used for transferring files between computers.
    Ports: TCP 20, 21
    Layer: Application Layer
    Zones: Work, Internal

9. FTPS (File Transfer Protocol Secure)

    Description: FTPS is the secure version of FTP, using SSL/TLS to encrypt data.
    Ports: TCP 990, 989 (control and data)
    Layer: Application Layer
    Zones: Work, Internal

10. SFTP (SSH File Transfer Protocol)

    Description: SFTP is a secure file transfer protocol that uses SSH.
    Port: TCP 22
    Layer: Application Layer
    Zones: Work, Internal

11. SMTP (Simple Mail Transfer Protocol)

    Description: SMTP is used for sending emails.
    Ports: TCP 25, 587
    Layer: Application Layer
    Zones: Work, Internal

12. IMAP (Internet Message Access Protocol)

    Description: IMAP is used for retrieving emails from a mail server.
    Port: TCP 143
    Layer: Application Layer
    Zones: Work, Internal

13. POP3 (Post Office Protocol 3)

    Description: POP3 is another protocol for retrieving emails.
    Port: TCP 110
    Layer: Application Layer
    Zones: Work, Internal

14. DNS (Domain Name System)

    Description: DNS translates domain names to IP addresses.
    Ports: UDP 53, TCP 53 (for larger queries)
    Layer: Application Layer
    Zones: Public, Work, Home

15. Telnet

    Description: Telnet is used for remote login and command execution, but it is not secure.
    Port: TCP 23
    Layer: Application Layer
    Zones: Work, Internal (not recommended due to lack of security)

16. SNMP (Simple Network Management Protocol)

    Description: SNMP is used for network management and monitoring.
    Ports: UDP 161, 162
    Layer: Application Layer
    Zones: Work, Internal

17. NTP (Network Time Protocol)

    Description: NTP is used for clock synchronization between computer systems.
    Port: UDP 123
    Layer: Application Layer
    Zones: Work, Internal

18. LDAP (Lightweight Directory Access Protocol)

    Description: LDAP is used for accessing and maintaining distributed directory information services.
    Ports: TCP 389, 636 (LDAPS)
    Layer: Application Layer
    Zones: Work, Internal

19. RDP (Remote Desktop Protocol)

    Description: RDP is used for remote access to desktops and applications.
    Port: TCP 3389
    Layer: Application Layer
    Zones: Work, Internal

20. SIP (Session Initiation Protocol)

    Description: SIP is used for initiating, maintaining, and terminating real-time sessions that include voice, video, and messaging applications.
    Ports: UDP 5060, TCP 5060, 5061 (SIPS)
    Layer: Application Layer
    Zones: Work, Internal

21. RTP (Real-Time Transport Protocol)

    Description: RTP is used for delivering audio and video over IP networks.
    Ports: Dynamic range (usually 16384-32767)
    Layer: Application Layer
    Zones: Work, Internal

22. ICMP (Internet Control Message Protocol)

    Description: ICMP is used for error messages and operational information queries.
    Port: N/A (uses protocol number 1)
    Layer: Network Layer
    Zones: All zones (typically used for diagnostics)

23. TFTP (Trivial File Transfer Protocol)

    Description: TFTP is a simple file transfer protocol.
    Port: UDP 69
    Layer: Application Layer
    Zones: Work, Internal

24. BGP (Border Gateway Protocol)

    Description: BGP is used for exchanging routing information between autonomous systems on the internet.
    Port: TCP 179
    Layer: Application Layer
    Zones: External, Work

25. GRE (Generic Routing Encapsulation)

    Description: GRE is used for tunneling protocols.
    Port: N/A (uses protocol number 47)
    Layer: Network Layer
    Zones: External, Work, Internal

26. IPSec (Internet Protocol Security)

    Description: IPSec is used for securing IP communications by authenticating and encrypting each IP packet.
    Port: UDP 500 (IKE), 4500 (NAT traversal)
    Layer: Network Layer
    Zones: External, Work, Internal

27. VNC (Virtual Network Computing)

    Description: VNC is used for remote desktop sharing.
    Port: TCP 5900
    Layer: Application Layer
    Zones: Work, Internal

28. Kerberos

    Description: Kerberos is a network authentication protocol.
    Port: UDP 88
    Layer: Application Layer
    Zones: Work, Internal

29. MQTT (Message Queuing Telemetry Transport)

    Description: MQTT is a lightweight messaging protocol for small sensors and mobile devices.
    Port: TCP 1883
    Layer: Application Layer
    Zones: Work, Internal

30. CoAP (Constrained Application Protocol)

    Description: CoAP is a protocol for simple, constrained environments such as IoT.
    Port: UDP 5683
    Layer: Application Layer
    Zones: Work, Internal




















2.2. FirewallD Services

FirewallD operates as a suite of interrelated services and components:

    firewalld.service: The main FirewallD service responsible for loading and enforcing firewall rules.
    firewalld: The FirewallD server daemon that runs in the background and listens for configuration changes.
    firewall-cmd: The primary command-line client used to interact with and configure FirewallD.
    firewall-config: A graphical user interface for FirewallD configuration, though most server environments rely on the command-line tool.
    firewall-offline-cmd: A command-line client used to build and inspect persistent firewall configurations when FirewallD isnâ€™t running.
    firewalld.conf: The main FirewallD configuration file located at /etc/firewalld/firewalld.conf.
    Configuration files: XML files located in /usr/lib/firewalld/ and /etc/firewalld/ that define zones, services, and other firewall configurations.






These components work together to provide the FirewallD functionality. The daemon listens for configuration changes from the clients, which it then applies to its internal configurations and the kernel-space firewalling components.
2.3. FirewallD Configuration Files

FirewallD uses a set of XML configuration files to define zones, services, ICMP types, and other firewall settings. These files are located in two directories:

    /usr/lib/firewalld/: This directory contains the default configuration files shipped with FirewallD. These should not be edited directly as updates to FirewallD can overwrite changes.
    /etc/firewalld/: This directory contains user-created or customized configuration files. Files here override the defaults in /usr/lib/firewalld/.








Key configuration files include:

    zones/: This directory contains XML files defining the different network zones. Each file describes the services, ports, protocols, and other settings allowed in the zone.
    services/: This directory contains XML files defining different network services. Each file lists the ports, protocols, and other settings associated with the service.
    icmptypes/: This directory contains XML files defining various ICMP types used in firewall rules.
    firewalld.conf: This is the main configuration file for FirewallD. It sets global settings like the default zone, minimal mark, and cleanup on exit options.







Hereâ€™s an example of a service definition XML file (/usr/lib/firewalld/services/http.xml):
XML

<?xml version="1.0" encoding="utf-8"?>
<service>
  <short>WWW (HTTP)</short>
  <description>HTTP is the protocol used to serve Web pages.</description>
  <port protocol="tcp" port="80"/>
</service>

This file defines the "http" service as using TCP on port 80.








Administrators can create their own service and zone definitions by placing XML files in the corresponding directories under /etc/firewalld/. This allows for customization without altering the default configurations.
3. Installation and Configuration
3.1. Installing FirewallD

FirewallD comes pre-installed on many Linux distributions, including Red Hat Enterprise Linux, CentOS, and Fedora. If itâ€™s not installed, you can install it using your distributionâ€™s package manager.







On Red Hat-based distributions:
bash

sudo yum install firewalld

On Debian and Ubuntu:
bash

sudo apt install firewalld

After installation, you need to start the FirewallD service and optionally enable it to start on boot.

Starting FirewallD:
bash

sudo systemctl start firewalld

Enabling FirewallD to start on boot:
bash

sudo systemctl enable firewalld





3.2. Configuring FirewallD

FirewallD can be configured using the command-line tool firewall-cmd, by editing configuration files, or through GUI tools like firewall-config.

The firewall-cmd command is the primary method for interacting with FirewallD. It allows you to view the current configuration, change settings, add or remove rules, and manage zones and services.








Here are a few common firewall-cmd commands:

    View the default zone:

bash

firewall-cmd --get-default-zone

    View the active zones:

bash

firewall-cmd --get-active-zones

    Add a service to the default zone:

bash

sudo firewall-cmd --add-service=http

    Add a port to the default zone:

bash

sudo firewall-cmd --add-port=8080/tcp

    Reload the firewall to apply changes:

bash

sudo firewall-cmd --reload

    Make a rule permanent (persist across reboots):

bash

sudo firewall-cmd --add-service=http --permanent

These are just a few examples. The firewall-cmd tool provides a wide range of options for configuring and managing FirewallD.







3.3. Checking FirewallD Status

You can check the status of FirewallD and view the current configuration using several firewall-cmd commands.

    Check if FirewallD is running:

bash

sudo firewall-cmd --state

    View the current FirewallD configuration:

bash

sudo firewall-cmd --list-all

This command displays the default zone, active zones, services, ports, and other FirewallD settings.

You can also use systemd commands to check the status of the FirewallD service:
bash

sudo systemctl status firewalld

This command shows whether the FirewallD service is active, the process ID, and any recent log entries.
4. Core Command Structure
4.1. Basic Syntax

The basic syntax for FirewallD commands is:
bash

firewall-cmd [OPTIONS] {COMMAND}






4.2. Common Options

Here are some commonly used options:

    --permanent: Make persistent changes that survive reboots.
    --zone: Specify the network zone to operate on.
    --add-*: Add rules, services, ports, etc.
    --remove-*: Remove rules, services, ports, etc.
    --list-*: Display current configurations.





5. Basic Firewall Management
5.1. Status and Information Commands

    Check overall firewall status:

bash

firewall-cmd --state

    List active zones:

bash

firewall-cmd --get-active-zones

    Show default zone:

bash

firewall-cmd --get-default-zone

    Detailed zone information:

bash

firewall-cmd --zone=public --list-all






6. Zones
6.1. Predefined Zones
public 	Untrusted networks 	Restrictive
internal 	Local trusted networks 	Moderate
external 	Networks with NAT 	High
dmz 	Demilitarized zone 	Highest
home 	Home network environment 	Relaxed
work 	Workplace network 	Balanced





6.2. Custom Zones

Create a new custom zone:
bash

firewall-cmd --permanent --new-zone=secure-network

Add interface to custom zone:
bash

firewall-cmd --permanent --zone=secure-network --add-interface=eth0







6.3. Configuring Zones

Configure zone-specific rules:
bash

firewall-cmd --permanent --zone=secure-network --add-service=ssh --add-service=http







6.4. Multi-Environment Network Setup

    DMZ Zone for Public-Facing Servers:

bash

firewall-cmd --permanent --new-zone=dmz-servers
firewall-cmd --permanent --zone=dmz-servers --add-service=http --add-service=https --add-service=ssh

    Internal Network Zone:

bash

firewall-cmd --permanent --zone=internal-network --add-service=nfs --add-service=samba






7. Services and Ports
7.1. Predefined Services

FirewallD comes with a set of predefined services that can be easily added to zones. These services are defined in XML files located in /usr/lib/firewalld/services/.
7.2. Custom Services

If you need to define a custom service, you can create an XML file in /etc/firewalld/services/. Hereâ€™s an example of defining a custom service for a hypothetical application:
XML

<?xml version="1.0" encoding="utf-8"?>
<service>
  <short>My Custom App</short>
  <description>My custom application service</description>
  <port protocol="tcp" port="12345"/>
  <port protocol="udp" port="12345"/>
</service>

Save this file as /etc/firewalld/services/my_custom_app.xml. You can then add this service to a zone:
bash

sudo firewall-cmd --permanent --zone=public --add-service=my_custom_app
sudo firewall-cmd --reload





7.3. Port Configuration

    Temporarily open a port:

bash

firewall-cmd --zone=public --add-port=8080/tcp

    Permanently open multiple ports:

bash

firewall-cmd --permanent --zone=public --add-port=8080/tcp --add-port=9090/udp
firewall-cmd --reload

    Remove a previously opened port:

bash

firewall-cmd --zone=public --remove-port=8080/tcp
firewall-cmd --reload






8. Rich Rules
8.1. Rich Rule Syntax

Rich rules use a specific syntax to define complex rules. Hereâ€™s a basic structure:
bash

rule family="ipv4" source address="192.168.1.1" port port="12345" protocol="tcp" accept





8.2. Creating Rich Rules

    Block specific IP address:

bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.1.100" drop'

    Allow specific service from a trusted IP address:

bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.1.100" service name="ssh" accept'





8.3. Advanced Traffic Control

    Limit SSH connection rate:

bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" service name="ssh" limit value="10/minute" accept'



8.4. Example Rich Rules

Provide examples of complex rich rules here.


9. Direct Rules
9.1. Direct Rule Syntax

Direct rules use the iptables syntax directly within FirewallD.

9.2. Creating Direct Rules

Add a direct rule:
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -m tcp -p tcp --dport 8080 -j ACCEPT
firewall-cmd --reload



10. Integration with NFTables
10.1. How FirewallD Uses NFTables



FirewallD can translate its rules to NFTables rules, providing a seamless transition from iptables.
10.2. Translating iptables Rules

Use tools like iptables-translate to convert iptables rules to NFTables syntax.


11. Troubleshooting

Continuing from section 11:
11. Troubleshooting


11.1. Diagnostic Flowchart



[Start Troubleshooting]
|
v
+-------------------+
| Firewall Status | â†’ Check overall status
| Verification | firewall-cmd --state
+-------------------+
|
v
+-------------------+
| Active Zones | â†’ Identify network zones
| Inspection | firewall-cmd --get-active-zones
+-------------------+
|
v
+-------------------+
| Zone Configurations | â†’ Examine zone rules
| Analysis | firewall-cmd --zone=public --list-all
+-------------------+
|
v
+-------------------+
| Service & Port | â†’ Verify open services/ports
| Verification | firewall-cmd --list-services
| | firewall-cmd --list-ports
+-------------------+
|
v
+-------------------+
| Log Investigation | â†’ Check system logs
| | journalctl -u firewalld
| | /var/log/firewalld
+-------------------+



11.2. Common Issues

    FirewallD Not Starting: Ensure that the firewall service is enabled and running.
    bash

sudo systemctl enable firewalld
sudo systemctl start firewalld

Rules Not Applying: Make sure to reload the firewall after making changes.
bash

    sudo firewall-cmd --reload

    Conflicts with Other Network Services: Check for conflicts with other firewall tools or network
    services that might be interfering with FirewallD.






11.3. Error Handling Matrix
Firewall Inactive 	1. Check service status - systemctl status firewalld 	1. Start the service - sudo
systemctl start firewalld
	2. Verify kernel modules - modprobe nf_conntrack 	2. Enable the service - sudo systemctl enable firewalld
Service Blocked 	1. List active services - firewall-cmd --list-services 	1. Add the service to the appropriate zone
	2. Check zone configuration - Verify service in correct zone 	2. Check for conflicting rules
Port Connection 	1. List open ports - firewall-cmd --list-ports 	1. Open the required port
Issues 	2. Check rich rules - Review rich rule configurations 	2. Adjust rich rules if necessary
11.4. Debugging with FirewallD

    Check FirewallD status:
    bash

sudo firewall-cmd --state

View active zones:
bash

firewall-cmd --get-active-zones

List all rules in a zone:
bash

    firewall-cmd --zone=public --list-all

11.5. Analyzing Logs

Check system logs for FirewallD-related messages:
bash

journalctl -u firewalld

12. Security Optimization
12.1. Advanced Security Hardening

    Disable ICMP redirects:
    bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" icmp-type name="redirect" drop'

Limit SSH connection attempts:
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" service name="ssh" limit value="5/minute" accept'

Log denied packets:
bash

    firewall-cmd --set-log-denied=all

13. Scripting and Automation
13.1. Comprehensive Firewall Configuration Script
bash

#!/bin/bash
# Firewall Configuration Management Script

configure_firewall() {
    # Reset to default configuration
    firewall-cmd --reload
    firewall-cmd --set-default-zone=public

    # Define security services
    local SERVICES=(
        "ssh"     # Secure Shell
        "http"    # Web server
        "https"   # Secure web server
        "cockpit" # Web management interface
    )

    # Define custom ports
    local PORTS=(
        "8080/tcp" # Custom application port
        "9090/tcp" # Monitoring interface
    )

    # Configure base services
    for service in "${SERVICES[@]}"; do
        firewall-cmd --permanent --add-service="$service"
    done

    # Open specific ports
    for port in "${PORTS[@]}"; do
        firewall-cmd --permanent --add-port="$port"
    done

    # Add security rules
    firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.100" accept'
    firewall-cmd --permanent --add-rich-rule='rule family="ipv4" service name="ssh" limit value="5/minute" accept'

    # Apply configuration
    firewall-cmd --reload
    firewall-cmd --list-all
}

# Execute configuration
configure_firewall


13.2. FirewallD D-Bus API

FirewallD provides a D-Bus API for advanced scripting and automation. More information can be found in the official FirewallD D-Bus API documentation.
13.3. Python FirewallD Bindings

Python bindings for FirewallD can be used for more complex automation tasks. You can use the firewall module in Python to interact with FirewallD.
13.4. Ansible Firewall Modules

Ansible provides modules for managing FirewallD configurations. These modules allow you to automate FirewallD settings using Ansible playbooks. More information can be found in the Ansible FirewallD module documentation.



14. Best Practices and Recommendations
14.1. Key Takeaways

    Implement zone-based security segmentation
    Use rich rules for granular access control
    Regularly review and update firewall configurations
    Log and monitor firewall activities
    Keep FirewallD and the system updated

14.2. Compatibility

    Supported Distributions: Red Hat, CentOS, Fedora
    Minimum Kernel Version: 3.6+
    Recommended: NetworkManager integration

14.3. Recommended Resources

    Official FirewallD Documentation
    Linux Network Security Best Practices
    Advanced Firewall Configuration Guides




15. Migrating from iptables
15.1. Comparing FirewallD to iptables

FirewallD provides a higher-level abstraction compared to iptables, making it easier to manage complex firewall rules using zones and services.
15.2. Converting iptables Rules

You can convert existing iptables rules to FirewallD using tools like iptables-translate or manually translating them using the FirewallD syntax.






----Advanced----





13.2. FirewallD D-Bus API Example
Here's an example of using the FirewallD D-Bus API to add a service to the default zone:




import dbus

bus = dbus.SystemBus()
firewalld = bus.get_object('org.fedoraproject.FirewallD1', '/org/fedoraproject/FirewallD1')
firewalld_iface = dbus.Interface(firewalld, dbus_interface='org.fedoraproject.FirewallD1')

# Add service to default zone
firewalld_iface.addService('', 'http', 0)




.3. Python FirewallD Bindings Example
This example demonstrates how to use the Python firewall bindings to create a new zone and add a source port:


from firewall.client import FirewallClient

# Create FirewallClient instance
fw = FirewallClient()

# Create new zone
fw.config().addZone("custom-zone", "My Custom Zone", default=False)

# Add source port to zone
fw.config().zone("custom-zone").addSource("192.168.1.0/24")

# Reload FirewallD
fw.reload()







 Ansible Firewall Modules Example
Here's an Ansible playbook snippet that uses the firewalld module to ensure SSH is enabled and port 8080 is open:
- name: Firewall configuration
  hosts: all
  tasks:
    - name: Ensure SSH is enabled
      firewalld:
        service: ssh
        permanent: yes
        state: enabled

    - name: Open port 8080
      firewalld:
        port: 8080/tcp
        permanent: yes
        state: enabled






FirewallD Quick Reference Cheat Sheet
Getting Help:

firewall-cmd --help

Status:

firewall-cmd --state
firewall-cmd --list-all

Reloading Changes:

firewall-cmd --reload

Zones:

firewall-cmd --get-default-zone
firewall-cmd --set-default-zone=<zone>
firewall-cmd --get-active-zones
firewall-cmd --new-zone=<zone>

Services:

firewall-cmd --list-services
firewall-cmd --add-service=<service>
firewall-cmd --remove-service=<service>

Ports:

firewall-cmd --list-ports
firewall-cmd --add-port=<port/protocol>
firewall-cmd --remove-port=<port/protocol>

Rich Rules:

firewall-cmd --list-rich-rules
firewall-cmd --add-rich-rule='<rule>'
firewall-cmd --remove-rich-rule='<rule>'

Permanent Changes:

Add --permanent flag to commands











What Does Masking a Service Mean?

When a service is masked, its service file is replaced with a symbolic link to /dev/null. This effectively makes the service unavailable for starting because systemd cannot find the actual service file.
Why Mask a Service?

    Prevent Conflicts: If two services are known to conflict with each other, you can mask one of them to ensure that it does not start and cause issues.
    Security: Masking a service can prevent it from being started by accident, which can be important for services that should not run for security reasons.
    Stability: Some services might cause instability on your system. Masking them ensures they cannot be started, which can help maintain system stability.

How to Mask and Unmask a Service
Mask a Service

To mask a service, you use the systemctl mask command:
bash

# Mask the service
sudo systemctl mask <service-name>

For example, to mask the httpd service:
bash

sudo systemctl mask httpd

This creates a symbolic link from the service file to /dev/null, effectively disabling it.
Unmask a Service

To unmask a service, you use the systemctl unmask command:
bash

# Unmask the service
sudo systemctl unmask <service-name>

For example, to unmask the httpd service:
bash

sudo systemctl unmask httpd

This removes the symbolic link to /dev/null, allowing the service to be started again.
Example Scenario

Imagine you have two services, httpd (Apache) and nginx, and you want to ensure that only one of them runs at a time to avoid port conflicts. You could mask the httpd service to ensure that only nginx runs:
bash

sudo systemctl mask httpd
sudo systemctl start nginx

Checking Service Status

You can check the status of a service to see if it is masked:
bash

systemctl status <service-name>

For example:
bash

systemctl status httpd

If the service is masked, the output will indicate that it is linked to /dev/null.
Conclusion

Masking a service in systemd is a powerful way to ensure that certain services do not run, either to prevent conflicts, enhance security, or maintain system stability. By using the mask and unmask commands, you can control the availability of services on your system.










16. Conclusion

FirewallD provides a powerful, flexible approach to Linux network security management, offering administrators comprehensive tools for protecting network infrastructure. By leveraging its zone-based configuration and rich rule capabilities, FirewallD simplifies the process of defining and managing firewall policies.






































-------------Advanced firewalld----------------------






FirewallD Advanced Configuration and Best Practices Guide
Table of Contents

    Practical Security Examples
    Performance Optimization
    High Availability
    Cloud Integration
    Monitoring and Metrics
    Emergency Response
    Testing and Validation
    IPv6-specific Considerations
    Compliance
    Final Review and Best Practices

1. PRACTICAL SECURITY EXAMPLES
Web Server Configuration

Basic Web Server Security Configuration
bash

firewall-cmd --permanent --new-zone=webserver
firewall-cmd --permanent --zone=webserver --add-service=http
firewall-cmd --permanent --zone=webserver --add-service=https
firewall-cmd --permanent --zone=webserver --add-service=ssh

Rate Limiting for SSH
bash

firewall-cmd --permanent --zone=webserver --add-rich-rule='rule service name="ssh" limit value="5/m" accept'

Allow Specific Admin IPs
bash

firewall-cmd --permanent --zone=webserver --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" service name="ssh" accept'

Mail Server Configuration

Mail Server Security Configuration
bash

firewall-cmd --permanent --new-zone=mailserver
firewall-cmd --permanent --zone=mailserver --add-service=smtp
firewall-cmd --permanent --zone=mailserver --add-service=smtps
firewall-cmd --permanent --zone=mailserver --add-service=imap
firewall-cmd --permanent --zone=mailserver --add-service=imaps
firewall-cmd --permanent --zone=mailserver --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="587" protocol="tcp" limit value="25/m" accept'

Database Server Configuration

Database Server Security Configuration
bash

firewall-cmd --permanent --new-zone=dbserver
firewall-cmd --permanent --zone=dbserver --add-port=3306/tcp
firewall-cmd --permanent --zone=dbserver --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" port port="3306" protocol="tcp" accept'
firewall-cmd --permanent --zone=dbserver --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="3306" protocol="tcp" reject'

Common Attack Prevention

DDoS Protection

Rate Limiting Connections
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="80" protocol="tcp" limit value="25/s" accept'

Connection Tracking Limits
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p tcp --syn -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECT

SYN Flood Protection
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT

Port Scanning Protection

Block Common Port Scanning
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT

2. PERFORMANCE OPTIMIZATION
Rule Ordering Best Practices

Place Most Frequently Matched Rules First
bash

firewall-cmd --permanent --zone=public --add-service=http
firewall-cmd --permanent --zone=public --add-service=smtp

Use Rich Rules for Complex Matching
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" service name="http" accept'

Resource Impact Analysis

Direct Rules (Highest Performance)
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p tcp --dport 80 -j ACCEPT

Service Rules (Balanced)
bash

firewall-cmd --permanent --zone=public --add-service=http

Rich Rules (Most Flexible but Higher Overhead)
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule service name="http" limit value="100/s" accept'

Performance Tips

Use Connection Tracking Efficiently
bash

echo 262144 > /proc/sys/net/netfilter/nf_conntrack_max

Optimize State Tracking
bash

firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -m state --state ESTABLISHED,RELATED -j ACCEPT

3. HIGH AVAILABILITY
Clustered Environment Configuration

Primary Node Configuration
bash

#!/bin/bash
# Export firewall configuration
firewall-cmd --runtime-to-permanent
firewall-cmd --permanent --list-all > firewall-config.txt

# Sync script
rsync -avz /etc/firewalld/ backup-node:/etc/firewalld/
ssh backup-node 'firewall-cmd --reload'

Failover Node Configuration
bash

#!/bin/bash
while true; do
  if ! ping -c 1 primary-node &> /dev/null; then
    # Take over primary IP
    ip addr add $VIP/24 dev eth0
    arping -U -I eth0 $VIP
  fi
  sleep 5
done

Synchronization Configuration
bash

#!/bin/bash
PRIMARY_NODE="192.168.1.10"
BACKUP_NODE="192.168.1.11"

# Export current configuration
firewall-cmd --runtime-to-permanent

# Sync configuration files
rsync -avz /etc/firewalld/ $BACKUP_NODE:/etc/firewalld/

# Reload firewall on backup
ssh $BACKUP_NODE 'firewall-cmd --reload'

4. CLOUD INTEGRATION
AWS Environment

AWS Security Group Equivalent in FirewallD
bash

firewall-cmd --permanent --new-zone=aws-web
firewall-cmd --permanent --zone=aws-web --add-rich-rule='rule family="ipv4" source address="10.0.0.0/16" accept'
firewall-cmd --permanent --zone=aws-web --add-service=http
firewall-cmd --permanent --zone=aws-web --add-service=https

Docker Integration

Allow Docker Container Communication
bash

firewall-cmd --permanent --zone=docker --add-source=172.17.0.0/16
firewall-cmd --permanent --zone=docker --add-masquerade

Container-Specific Rules
bash

firewall-cmd --permanent --zone=docker --add-rich-rule='rule family="ipv4" source address="172.17.0.0/16" port port="3306" protocol="tcp" accept'

Kubernetes Integration

Kubernetes Node Configuration
bash

firewall-cmd --permanent --zone=kubernetes --add-source=10.244.0.0/16
firewall-cmd --permanent --zone=kubernetes --add-port=6443/tcp
firewall-cmd --permanent --zone=kubernetes --add-port=2379-2380/tcp
firewall-cmd --permanent --zone=kubernetes --add-port=10250/tcp
firewall-cmd --permanent --zone=kubernetes --add-port=10251/tcp
firewall-cmd --permanent --zone=kubernetes --add-port=10252/tcp

5. MONITORING AND METRICS
Integration with Prometheus

Enable Firewall Logging
bash

firewall-cmd --set-log-denied=all

Prometheus Configuration
YAML

global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'firewalld'
    static_configs:
      - targets: ['localhost:9090']

Alert Configuration

Alert Rules in Prometheus
YAML

groups:
  - name: firewall
    rules:
      - alert: HighRateOfDroppedPackets
        expr: rate(firewall_dropped_packets_total[5m]) > 100
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: High rate of dropped packets

Metrics Collection Script
bash

#!/bin/bash
# Collect firewall metrics
while true; do
  # Count dropped packets
  dropped=$(grep "DROP" /var/log/firewalld | wc -l)
  # Count accepted connections
  accepted=$(grep "ACCEPT" /var/log/firewalld | wc -l)
  # Write to Prometheus format
  echo "firewall_dropped_packets_total $dropped" > /var/lib/node_exporter/firewall.prom
  echo "firewall_accepted_packets_total $accepted" >> /var/lib/node_exporter/firewall.prom
  sleep 60
done

6. EMERGENCY RESPONSE
Emergency Lockdown Procedure

Emergency Lockdown Script
bash

#!/bin/bash
function emergency_lockdown() {
  # Block all incoming traffic except SSH from admin IPs
  firewall-cmd --permanent --zone=public --remove-service=http
  firewall-cmd --permanent --zone=public --remove-service=https
  firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" service name="ssh" accept'
  firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" drop'
  # Reload firewall
  firewall-cmd --reload
  # Log the event
  logger "Emergency firewall lockdown activated"
}

# Usage
emergency_lockdown

Common Security Incidents Response

Brute Force Attack Response

Block Attacking IP
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="ATTACKER_IP" drop'

Increase SSH Security
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule service name="ssh" limit value="3/m" accept'

DDoS Attack Response

Enable Rate Limiting
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="80" protocol="tcp" limit value="10/s" accept'

Block Common DDoS Sources
bash

firewall-cmd --permanent --direct --add-chain ipv4 filter DOS_PROTECT
firewall-cmd --permanent --direct --add-rule ipv4 filter DOS_PROTECT 0 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

7. TESTING AND VALIDATION
Testing Methodology

Firewall Rule Testing Script
bash

#!/bin/bash
function test_rule() {
  local service=$1
  local port=$2
  # Test TCP connection
  nc -zv localhost $port
  # Test UDP if applicable
  nc -zuv localhost $port
  # Check firewall logs
  grep $port /var/log/firewalld
}

# Example usage
test_rule http 80
test_rule https 443

Validation Script
bash

#!/bin/bash
# Validate firewall configuration

# Check basic connectivity
function test_basic_connectivity() {
  # Test ping
  ping -c 1 8.8.8.8 || echo "Ping failed"
  # Test HTTP
  curl -s -o /dev/null -w "%{http_code}" http://example.com || echo "HTTP failed"
  # Test HTTPS
  curl -s -o /dev/null -w "%{http_code}" https://example.com || echo "HTTPS failed"
}

# Check rule consistency
function check_rule_consistency() {
  # Compare runtime vs permanent configuration
  diff <(firewall-cmd --list-all) <(firewall-cmd --permanent --list-all)
}

# Run tests
test_basic_connectivity
check_rule_consistency

8. IPv6-SPECIFIC CONSIDERATIONS
IPv6 Security Configuration

Basic IPv6 Security
bash

firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv6" source address="2001:db8::/32" service name="ssh" accept'

ICMPv6 Security
bash

firewall-cmd --permanent --direct --add-rule ipv6 filter INPUT 0 -p icmpv6 --icmpv6-type echo-request -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv6 filter INPUT 0 -p icmpv6 --icmpv6-type neighbor-advertisement -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv6 filter INPUT 0 -p icmpv6 --icmpv6-type neighbor-solicitation -j ACCEPT

Dual-Stack Configuration

Configure Both IPv4 and IPv6
bash

firewall-cmd --permanent --zone=public --add-service=ssh
firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" service name="ssh" accept'
firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv6" source address="2001:db8::/32" service name="ssh" accept'

9. COMPLIANCE
PCI-DSS Compliance Template
bash

#!/bin/bash
# PCI-DSS compliance configuration

# Requirement 1: Install and maintain a firewall configuration
firewall-cmd --permanent --zone=public --remove-service=all
firewall-cmd --permanent --zone=public --add-service=ssh
firewall-cmd --permanent --zone=public --add-service=https

# Requirement 2: Change vendor-supplied defaults
firewall-cmd --permanent --zone=public --add-rich-rule='rule service name="ssh" port port="2222" accept'

# Requirement 4: Encrypt transmission of cardholder data
firewall-cmd --permanent --zone=public --remove-service=http
firewall-cmd --permanent --zone=public --add-service=https

# Apply changes
firewall-cmd --reload

HIPAA Compliance Template
bash

#!/bin/bash
# HIPAA compliance configuration

# Access Control
firewall-cmd --permanent --zone=public --remove-service=all
firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="10.0.0.0/24" service name="ssh" accept'

# Encryption Requirements
firewall-cmd --permanent --zone=public --add-service=https
firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="80" protocol="tcp" reject'

# Logging
firewall-cmd --set-log-denied=all

# Apply changes
firewall-cmd --reload

Audit Preparation Guidelines

Documentation Requirements
bash

#!/bin/bash
# Generate audit documentation

# Export current configuration
firewall-cmd --list-all > firewall_config.txt

# Export permanent configuration
firewall-cmd --permanent --list-all > firewall_permanent_config.txt

# Export rich rules
firewall-cmd --list-rich-rules > rich_rules.txt

# Generate change log
grep "firewall" /var/log/audit/audit.log > firewall_changes.log

Compliance Checking Tools
bash

#!/bin/bash
# Compliance checking script

# Check required services
function check_required_services() {
  local required_services=("ssh" "https")
  for service in "${required_services[@]}"; do
    if ! firewall-cmd --list-services | grep -q "$service"; then
      echo "FAIL: Required service $service not enabled"
    else
      echo "PASS: Required service $service enabled"
    fi
  done
}

# Check prohibited services
function check_prohibited_services() {
  local prohibited_services=("telnet" "ftp")
  for service in "${prohibited_services[@]}"; do
    if firewall-cmd --list-services | grep -q "$service"; then
      echo "FAIL: Prohibited service $service is enabled"
    else
      echo "PASS: Prohibited service $service is disabled"
    fi
  done
}

# Check logging configuration
function check_logging() {
  if [ "$(firewall-cmd --get-log-denied)" == "all" ]; then
    echo "PASS: Logging properly configured"
  else
    echo "FAIL: Logging not properly configured"
  fi
}

# Run all checks
check_required_services
check_prohibited_services
check_logging

Regular Compliance Maintenance

Weekly Tasks
bash

#!/bin/bash
# Weekly compliance check script

# Check firewall status
systemctl status firewalld

# Export current configuration
firewall-cmd --list-all > /var/log/firewall/weekly_config.txt

# Compare with previous week
diff /var/log/firewall/weekly_config.txt /var/log/firewall/weekly_config.txt.old

# Backup current config
cp /var/log/firewall/weekly_config.txt /var/log/firewall/weekly_config.txt.old

Monthly Tasks
bash

#!/bin/bash
# Monthly compliance check script

# Full audit of firewall rules
firewall-cmd --list-all-zones > /var/log/firewall/monthly_audit.txt

# Check for unauthorized changes
grep "firewall" /var/log/audit/audit.log | grep -v "authorized_change"

# Review rich rules
firewall-cmd --list-rich-rules > /var/log/firewall/monthly_rich_rules.txt

FINAL REVIEW AND BEST PRACTICES

Regular Maintenance Checklist

    Weekly configuration review
    Monthly security audit
    Quarterly rule optimization






























